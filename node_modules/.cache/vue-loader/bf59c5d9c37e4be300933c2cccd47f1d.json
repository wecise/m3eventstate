{"remainingRequest":"/Users/cnwangzd/Documents/cnwangzd/wecise/m3/apps/m3search/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/cnwangzd/Documents/cnwangzd/wecise/m3/apps/m3search/src/components/graph/GraphHandler.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/cnwangzd/Documents/cnwangzd/wecise/m3/apps/m3search/src/components/graph/GraphHandler.vue","mtime":1629791743822},{"path":"/Users/cnwangzd/Documents/cnwangzd/wecise/m3/apps/m3search/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cnwangzd/Documents/cnwangzd/wecise/m3/apps/m3search/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/cnwangzd/Documents/cnwangzd/wecise/m3/apps/m3search/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/cnwangzd/Documents/cnwangzd/wecise/m3/apps/m3search/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAnbXhncmFwaC9qYXZhc2NyaXB0L3NyYy9jc3MvY29tbW9uLmNzcyc7CgppbXBvcnQgXyBmcm9tICdsb2Rhc2gnOwppbXBvcnQgJCBmcm9tICdqcXVlcnknOwppbXBvcnQgbXhncmFwaCBmcm9tICcuL214R3JhcGguanMnOwpjb25zdCB7bXhFZGl0b3IsbXhHcmFwaCxteENvbnN0YW50cyxteFBhbm5pbmdIYW5kbGVyLG14R3JhcGhIYW5kbGVyLG14R3VpZGUsbXhFZGdlSGFuZGxlcixteENsaWVudCxteFJlY3RhbmdsZVNoYXBlLG14UnViYmVyYmFuZCxteENlbGxPdmVybGF5LG14T3V0bGluZSxteEltYWdlLG14UG9pbnQsbXhFZGdlU3R5bGUsbXhDZWxsVHJhY2tlcixteFV0aWxzLG14Q29kZWMsbXhFdmVudCxteEhpZXJhcmNoaWNhbExheW91dCxteE1vcnBoaW5nLG14RmFzdE9yZ2FuaWNMYXlvdXQsbXhDb21wYWN0VHJlZUxheW91dCxteENpcmNsZUxheW91dH0gPSBteGdyYXBoOwoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICJHcmFwaFZpZXciLAogIHByb3BzOiB7CiAgICBncmFwaERhdGE6IE9iamVjdCwKICAgIGdsb2JhbDogT2JqZWN0CiAgfSwKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgZ3JhcGg6IHsKICAgICAgICAgICAgZWRpdG9yOm51bGwsCiAgICAgICAgICAgIGRhdGE6IHsKICAgICAgICAgICAgICAgIG5vZGVzOiBbXSwKICAgICAgICAgICAgICAgIGVkZ2VzOiBbXQogICAgICAgICAgICB9LAogICAgICAgICAgICBjb250cm9sOnsKICAgICAgICAgICAgICAgIGlmSWNvbjogdHJ1ZSwKICAgICAgICAgICAgICAgIG91dGxpbmU6IHsKICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLAogICAgICAgICAgICAgICAgICAgIGluc3Q6IG51bGwKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICB0b29sYmFyOnsKICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZQogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIHJlZnJlc2g6ewogICAgICAgICAgICAgICAgICAgIGluc3Q6IG51bGwsCiAgICAgICAgICAgICAgICAgICAgZW5hYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbDogMTUqMTAwMAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBsYXlvdXQ6IHsKICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICdoaWVyYXJjaGljYWxfdmVydGljYWwnCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHN0eWxlOiB7CiAgICAgICAgICAgICAgICBncmlkOiB7CiAgICAgICAgICAgICAgICAgICAgc2hvdzogZmFsc2UKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICB2ZXJ0ZXg6ewogICAgICAgICAgICAgICAgICAgIGFsaWduOiB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnJywKICAgICAgICAgICAgICAgICAgICAgICAgbGlzdDogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflt6blr7npvZAnLCBpY29uOicnLCB2YWx1ZTonbXhDb25zdGFudHMuQUxJR05fTEVGVCd9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflsYXkuK0nLCBpY29uOicnLCB2YWx1ZTonbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSJ30sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+WPs+Wvuem9kCcsIGljb246JycsIHZhbHVlOidteENvbnN0YW50cy5BTElHTl9SSUdIVCd9LAogICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICfkuIrlr7npvZAnLCBpY29uOicnLCB2YWx1ZTonbXhDb25zdGFudHMuQUxJR05fVE9QJ30sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+S4remXtCcsIGljb246JycsIHZhbHVlOidteENvbnN0YW50cy5BTElHTl9NSURETEUnfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5LiL5a+56b2QJywgaWNvbjonJywgdmFsdWU6J214Q29uc3RhbnRzLkFMSUdOX0JPVFRPTSd9CiAgICAgICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgZWRnZTogewogICAgICAgICAgICAgICAgICAgIGVuZEFycm93OiAnY2xhc3NpYycsCiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsCiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICcjMzMzMzMzJywKICAgICAgICAgICAgICAgICAgICB2YWx1ZTogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2lzb21ldHJpYzEnLCBjblRpdGxlOifnrYnot50xJywgdGl0bGU6J2lzb21ldHJpY0VkZ2VTdHlsZScsIGtleXM6W214Q29uc3RhbnRzLlNUWUxFX0VER0UsIG14Q29uc3RhbnRzLlNUWUxFX0VMQk9XLCBteENvbnN0YW50cy5TVFlMRV9DVVJWRUQsIG14Q29uc3RhbnRzLlNUWUxFX05PRURHRVNUWUxFXSwgdmFsdWVzOlsnaXNvbWV0cmljRWRnZVN0eWxlJywgbnVsbCwgbnVsbCwgbnVsbF0KICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICBsaXN0OiBbCiAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzdHJhaWdodCcsIGNuVGl0bGU6J+ebtOe6vycsIHRpdGxlOidpc29tZXRyaWNFZGdlU3R5bGUnLCBrZXlzOltteENvbnN0YW50cy5TVFlMRV9FREdFLCBteENvbnN0YW50cy5TVFlMRV9DVVJWRUQsIG14Q29uc3RhbnRzLlNUWUxFX05PRURHRVNUWUxFXSwgdmFsdWVzOltudWxsLCBudWxsLCBudWxsXQogICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb3J0aG9nb25hbCcsIGNuVGl0bGU6J+ato+S6pCcsIHRpdGxlOidvcnRob2dvbmFsRWRnZVN0eWxlJywga2V5czpbbXhDb25zdGFudHMuU1RZTEVfRURHRSwgbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVELCBteENvbnN0YW50cy5TVFlMRV9OT0VER0VTVFlMRV0sIHZhbHVlczpbJ29ydGhvZ29uYWxFZGdlU3R5bGUnLCBudWxsLCBudWxsXQogICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2ltcGxlMScsIGNuVGl0bGU6J+eugOWNlTEnLCB0aXRsZTonZWxib3dFZGdlU3R5bGUnLCBrZXlzOltteENvbnN0YW50cy5TVFlMRV9FREdFLCBteENvbnN0YW50cy5TVFlMRV9FTEJPVywgbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVELCBteENvbnN0YW50cy5TVFlMRV9OT0VER0VTVFlMRV0sIHZhbHVlczpbJ2VsYm93RWRnZVN0eWxlJywgbnVsbCwgbnVsbCwgbnVsbF0KICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NpbXBsZTInLCBjblRpdGxlOifnroDljZUyJywgdGl0bGU6J2VsYm93RWRnZVN0eWxlJywga2V5czpbbXhDb25zdGFudHMuU1RZTEVfRURHRSwgbXhDb25zdGFudHMuU1RZTEVfRUxCT1csIG14Q29uc3RhbnRzLlNUWUxFX0NVUlZFRCwgbXhDb25zdGFudHMuU1RZTEVfTk9FREdFU1RZTEVdLCB2YWx1ZXM6WydlbGJvd0VkZ2VTdHlsZScsICd2ZXJ0aWNhbCcsIG51bGwsIG51bGxdCiAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpc29tZXRyaWMxJywgY25UaXRsZTon562J6LedMScsIHRpdGxlOidpc29tZXRyaWNFZGdlU3R5bGUnLCBrZXlzOltteENvbnN0YW50cy5TVFlMRV9FREdFLCBteENvbnN0YW50cy5TVFlMRV9FTEJPVywgbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVELCBteENvbnN0YW50cy5TVFlMRV9OT0VER0VTVFlMRV0sIHZhbHVlczpbJ2lzb21ldHJpY0VkZ2VTdHlsZScsIG51bGwsIG51bGwsIG51bGxdCiAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpc29tZXRyaWMyJywgY25UaXRsZTon562J6LedMicsIHRpdGxlOidpc29tZXRyaWNFZGdlU3R5bGUnLCBrZXlzOltteENvbnN0YW50cy5TVFlMRV9FREdFLCBteENvbnN0YW50cy5TVFlMRV9FTEJPVywgbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVELCBteENvbnN0YW50cy5TVFlMRV9OT0VER0VTVFlMRV0sIHZhbHVlczpbJ2lzb21ldHJpY0VkZ2VTdHlsZScsICd2ZXJ0aWNhbCcsIG51bGwsIG51bGxdCiAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdlbnRpdHlSZWxhdGlvbicsIGNuVGl0bGU6J+WunuS9k+WFs+iBlCcsIHRpdGxlOidlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZScsIGtleXM6W214Q29uc3RhbnRzLlNUWUxFX0VER0UsIG14Q29uc3RhbnRzLlNUWUxFX0NVUlZFRCwgbXhDb25zdGFudHMuU1RZTEVfTk9FREdFU1RZTEVdLCB2YWx1ZXM6WydlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZScsIG51bGwsIG51bGxdCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHBhdGg6IHsKICAgICAgICAgICAgICAgIGxpc3Q6W10sCiAgICAgICAgICAgICAgICBjb2xvcnM6WycjZmYwMDAwJywnI2ZmZDcwMCcsJyM2NjY2NjYnLCcjMDBmZmZmJywnIzQwZTBkMCcsJyNmZjczNzMnLCcjZDNmZmNlJywnIzMzOTlmZicsJyMwMDAwODAnLCcjNjZjY2NjJywnI2EwZGI4ZScsJyM3OTQwNDQnLCcjNjg5N2JiJywnI2NjMDAwMCddLAogICAgICAgICAgICB9LAogICAgICAgICAgICBlZGdlczogewogICAgICAgICAgICAgICAgdmFsdWU6ICIiLAogICAgICAgICAgICAgICAgbGlzdDogW10sCiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7CiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICIiLAogICAgICAgICAgICAgICAgICAgIGxpc3Q6IFtdCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgfQogICAgfTsKICB9LAogIHdhdGNoOiB7CiAgICAgICAgZ3JhcGhEYXRhOnsKICAgICAgICAgIGhhbmRsZXIoKXsKICAgICAgICAgICAgICB0aGlzLnNldEdyYXBoRGF0YSgpOwogICAgICAgICAgfSwKICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZQogICAgICAgIH0sCiAgICAgICAgJ2dyYXBoLmNvbnRyb2wucmVmcmVzaC5lbmFibGUnOnsKICAgICAgICAgICAgaGFuZGxlcih2YWwpewogICAgICAgICAgICAgICAgaWYodmFsKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5jb250cm9sLnJlZnJlc2guaW5zdCA9IHNldEludGVydmFsKCgpPT57CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25SZWZyZXNoQ2VsbFN0YXR1cygpOwogICAgICAgICAgICAgICAgICAgIH0sdGhpcy5ncmFwaC5jb250cm9sLnJlZnJlc2guaW50ZXJ2YWwpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuJG1lc3NhZ2UoewogICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAiaW5mbyIsCiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICLoh6rliqjliLfmlrDlvIDlkK8iCiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmdyYXBoLmNvbnRyb2wucmVmcmVzaC5pbnN0KTsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRtZXNzYWdlKHsKICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogImluZm8iLAogICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAi6Ieq5Yqo5Yi35paw5YWz6ZetIgogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGltbWVkaWF0ZTp0cnVlCiAgICAgICAgfSwKICB9LAogIGNyZWF0ZWQoKXsKICAgIHRoaXMuaW5pdCgpOwogIH0sCiAgbW91bnRlZCgpewoKICAgICAgdGhpcy5pbml0R3JhcGgoKTsKCiAgICAgIHRoaXMuZXZlbnRIdWIuJG9uKCJncmFwaC1wb3NpdGlvbiIsKHYpPT57CiAgICAgICAgICB0aGlzLm9uQ2VsbFBvc2l0aW9uKHYucm93LHYuaEZsYWcsdi52RmxhZyk7CiAgICAgIH0pCgogIH0sCiAgbWV0aG9kczogewogICAgLy8g5Yid5aeL5YyWCiAgICBpbml0KCl7CiAgICAgICAgdGhpcy5tMy5jYWxsRlMoIi9tYXRyaXgvbTNncmFwaC9lZGdlcy5qcyIsbnVsbCkudGhlbiggKHJ0bik9PnsKICAgICAgICAgICAgdGhpcy5ncmFwaC5lZGdlcy5saXN0ID0gcnRuLm1lc3NhZ2U7CiAgICAgICAgfSApOwoKICAgICAgICAvLyDnirbmgIHliLfmlrDmoIflv5cKICAgICAgICB0aGlzLmdyYXBoLmNvbnRyb2wucmVmcmVzaC5lbmFibGUgPSAobG9jYWxTdG9yYWdlLmdldEl0ZW0oIkdSQVBILVNUQVRVUy1JRlJFRlJFU0giKSA9PSAndHJ1ZScpOwoKICAgICAgICAvLyDoioLngrnmmK/lkKblj6/ku6Xnp7vliqggCiAgICAgICAgbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNldE1vdmVFbmFibGVkKHRydWUpOwogICAgICAgIC8v5pi+56S66IqC54K55L2N572u5qCH5bC6ICAKICAgICAgICBteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZ3VpZGVzRW5hYmxlZCA9IHRydWU7CgogICAgICAgIC8vIEFsdCBkaXNhYmxlcyBndWlkZXMKICAgICAgICBteEd1aWRlLnByb3RvdHlwZS5pc0VuYWJsZWRGb3JFdmVudCA9IGZ1bmN0aW9uKGV2dCl7CiAgICAgICAgICAgIHJldHVybiAhbXhFdmVudC5pc0FsdERvd24oZXZ0KTsKICAgICAgICB9OwoKICAgICAgICAvLyBFbmFibGVzIHNuYXBwaW5nIHdheXBvaW50cyB0byB0ZXJtaW5hbHMKICAgICAgICBteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5zbmFwVG9UZXJtaW5hbHMgPSB0cnVlOwoKICAgIH0sCiAgICAvLyDliqDovb3lm77mlbDmja4KICAgIHNldEdyYXBoRGF0YSgpewogICAgICAgIAogICAgICAgIGlmKF8uaXNFbXB0eSh0aGlzLmdyYXBoRGF0YSkpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMuZ3JhcGguZGF0YSA9IHRoaXMuZ3JhcGhEYXRhOwogICAgICAgICAgICB0aGlzLm9uUmVsb2FkKCk7CiAgICAgICAgfQogICAgfSwKICAgIC8vIOWIneWni+WMluWbvuadvwogICAgaW5pdEdyYXBoKCl7CiAgICAgICAgCiAgICAgICAgdGhpcy5ncmFwaC5lZGl0b3IgPSBuZXcgbXhFZGl0b3IoKTsKICAgICAgICB0aGlzLmdyYXBoLmVkaXRvci5zZXRHcmFwaENvbnRhaW5lcih0aGlzLiRyZWZzLmdyYXBoQ29udGFpbmVyLiRlbCk7CiAgICAgICAgbGV0IGdyYXBoID0gdGhpcy5ncmFwaC5lZGl0b3IuZ3JhcGg7CgogICAgICAgIC8vIOaYr+WQpuWFgeiuuOW5s+enu+OAgnRydWXvvJrooajnpLrmjInkvY9TaGlmdCvlt6bplK7mi5bliqjml7bvvIzmlbTkuKpncmFwaOenu+WKqO+8mwogICAgICAgIC8vIGZhbHNl77ya5oyJ5L2PU2hpZnQr5bem6ZSu5ouW5Yqo5pe277yM6YCJ5Lit55qE5Zu+5b2i5rC05bmz5pa55ZCR5oiW6ICF5Z6C55u05pa55ZCR5bmz56e744CCCiAgICAgICAgZ3JhcGguc2V0UGFubmluZyh0cnVlKTsKICAgICAgICBteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5pc1Bhbm5pbmdUcmlnZ2VyID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH07CgogICAgICAgIC8vIOemgeatouaUueWPmOiKgueCueWkp+WwjwogICAgICAgIGdyYXBoLnNldENlbGxzUmVzaXphYmxlKGZhbHNlKTsKICAgICAgICAvLyDnpoHmraLoioLngrnmloflrZfnvJbovpHlip/og70KICAgICAgICBncmFwaC5zZXRDZWxsc0VkaXRhYmxlKGZhbHNlKTsKICAgICAgICAKICAgICAgICAvLyDnpoHmraLov57nur/np7vliqgKICAgICAgICBncmFwaC5kaXNjb25uZWN0T25Nb3ZlID0gZmFsc2U7CiAgICAgICAgCgogICAgICAgIC8vIOWFgeiuuOi/nue6v+eahOebruagh+WSjOa6kOaYr+WQjOS4gOWFg+e0oCAKICAgICAgICBncmFwaC5zZXRBbGxvd0xvb3BzKHRydWUpOyAKICAgICAgICAvLyDlsYXkuK3nvKnmlL4KICAgICAgICBncmFwaC5jZW50ZXJab29tID0gdHJ1ZTsKICAgICAgICAvLyBUb29sdGlwcyBvbiB0b3VjaCBkZXZpY2VzCiAgICAgICAgZ3JhcGguc2V0VG9vbHRpcHMoIW14Q2xpZW50LklTX1RPVUNIKTsKICAgICAgICAvLyDmlK/mjIFIdG1sCiAgICAgICAgZ3JhcGguc2V0SHRtbExhYmVscyh0cnVlKTsKCiAgICAgICAgLy8g5Y676ZSv6b2/5pWI5p6cCiAgICAgICAgbXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUuY3Jpc3AgPSB0cnVlOwoKICAgICAgICAvLyDpvKDmoIfmoYbpgIkKICAgICAgICBuZXcgbXhSdWJiZXJiYW5kKGdyYXBoKTsKICAgICAgICAKICAgICAgICAvLyDpooTop4jml7bpvKDmoIfmgqzmta7liLDoioLngrnml7bvvIzmlLnlj5jpvKDmoIfmoLflvI8KICAgICAgICBncmFwaC5nZXRDdXJzb3JGb3JDZWxsID0gZnVuY3Rpb24oY2VsbCl7CiAgICAgICAgICAgIGlmIChjZWxsICE9IG51bGwgJiYgY2VsbC52YWx1ZSAhPSBudWxsICYmIGNlbGwudmVydGV4ID09MSApewogICAgICAgICAgICAgICAgcmV0dXJuICdwb2ludGVyJzsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDpooTop4jml7bpvKDmoIfmgqzmta7liLDoioLngrnml7bvvIzmlLnlj5joioLngrnmoLflvI8KICAgICAgICBuZXcgbXhDZWxsVHJhY2tlcihncmFwaCk7CgogICAgICAgIC8vIFNldHMgZ2xvYmFsIHN0eWxlcwogICAgICAgIHZhciBzdHlsZSA9IGdyYXBoLmdldFN0eWxlc2hlZXQoKS5nZXREZWZhdWx0RWRnZVN0eWxlKCk7CiAgICAgICAgc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRURHRV0gPSBteEVkZ2VTdHlsZS5FbnRpdHlSZWxhdGlvbjsKICAgICAgICBzdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1VOREVEXSA9IHRydWU7CiAgICAgICAgc3R5bGVbbXhDb25zdGFudHMuRURHRV9TRUxFQ1RJT05fU1RST0tFV0lEVEhdID0gMzsKICAgICAgICBzdHlsZVtteENvbnN0YW50cy5TVFlMRV9MQUJFTF9CQUNLR1JPVU5EQ09MT1JdID0gJ3RyYW5zcGFyZW50JzsKICAgICAgICBzdHlsZVtteENvbnN0YW50cy5TVFlMRV9MQUJFTF9QQURESU5HXSA9IDU7CgoKICAgICAgICBzdHlsZSA9IGdyYXBoLmdldFN0eWxlc2hlZXQoKS5nZXREZWZhdWx0VmVydGV4U3R5bGUoKTsKICAgICAgICBzdHlsZVtteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1JdID0gJyMyZjhlZTcnOwogICAgICAgIHN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUl0gPSAnIzMzMzMzMyc7CiAgICAgICAgc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVFNJWkVdID0gJzE0JzsKICAgICAgICBzdHlsZVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV0gPSAnc3dpbWxhbmUnOwogICAgICAgIHN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkddID0gJzEwJzsKICAgICAgICBzdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdID0gMzA7CiAgICAgICAgc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRDT0xPUl0gPSAnIzQxOWVmZSc7CiAgICAgICAgc3R5bGVbbXhDb25zdGFudHMuVkVSVEVYX1NFTEVDVElPTl9TVFJPS0VXSURUSF0gPSAzOwogICAgICAgIHN0eWxlW214Q29uc3RhbnRzLlZFUlRFWF9TRUxFQ1RJT05fQ09MT1JdID0gJyNmZjAwMDAnOwoKICAgICAgICAvLyDpooTop4jml7bpvKDmoIfmgqzmta7liLDoioLngrnml7bvvIzmlLnlj5joioLngrnmoLflvI8KICAgICAgICBuZXcgbXhDZWxsVHJhY2tlcihncmFwaCk7CgogICAgICAgIC8vIOmmluWFiOemgeeUqOa1j+iniOWZqOWPs+mUruiPnOWNlQogICAgICAgIG14RXZlbnQuZGlzYWJsZUNvbnRleHRNZW51KHRoaXMuJGVsKTsKICAgICAgICAvLyDlj7PplK7oj5zljZUKICAgICAgICBncmFwaC5wb3B1cE1lbnVIYW5kbGVyLmZhY3RvcnlNZXRob2QgPSAobWVudSwgY2VsbCwgZXZ0KT0+ewogICAgICAgICAgICB0aGlzLmNyZWF0ZVBvcHVwTWVudSh0aGlzLmdyYXBoLmVkaXRvciwgZ3JhcGgsIG1lbnUsIGNlbGwsIGV2dCk7CiAgICAgICAgfTsKCiAgICAgICAgdGhpcy5pbml0R3JhcGhFdmVudChncmFwaCk7CgogICAgfSwKICAgIGluaXRHcmFwaEV2ZW50KGdyYXBoKXsKICAgICAgICAvLyDliJ3lp4vljJbmu5rova7lm77nvKnmlL7kuovku7bnm5HlkKwKICAgICAgICB0aGlzLmFkZFNjcm9sbExpc3RlbmVyKGdyYXBoKTsKCiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdmVydGV4CiAgICAgICAgZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5BRERfQ0VMTFMsIF8uZGVib3VuY2UoKCk9PiB7CiAgICAgICAgICAgIHRoaXMub25SZWZyZXNoQ2VsbFN0YXR1cygpOwogICAgICAgIH0pLDEwMDApOwoKICAgICAgICAvLyDliJ3lp4vljJbpubDnnLzop4blm74KICAgICAgICB0aGlzLm9uSW5pdE91dGxpbmUoZ3JhcGgpOwoKICAgICAgICAvLyDnm5HlkKzmi5bmi73kuovku7YKICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy4kcmVmcy5ncmFwaENvbnRhaW5lci4kZWw7CiAgICAgICAgbXhFdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdkcmFnb3ZlcicsIChldnQpPT57CiAgICAgICAgICAgIGlmIChncmFwaC5pc0VuYWJsZWQoKSl7CiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7CiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIC8vIOebkeWQrOaLluWFpeS6i+S7tgogICAgICAgIG14RXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnZHJvcCcsIChldnQpPT57CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAoZ3JhcGguaXNFbmFibGVkKCkpewogICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpOwogICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7CgogICAgICAgICAgICAgICAgLy8gR2V0cyBkcm9wIGxvY2F0aW9uIHBvaW50IGZvciB2ZXJ0ZXgKICAgICAgICAgICAgICAgIHZhciBwdCA9IG14VXRpbHMuY29udmVydFBvaW50KGdyYXBoLmNvbnRhaW5lciwgbXhFdmVudC5nZXRDbGllbnRYKGV2dCksIG14RXZlbnQuZ2V0Q2xpZW50WShldnQpKTsKICAgICAgICAgICAgICAgIHZhciB0ciA9IGdyYXBoLnZpZXcudHJhbnNsYXRlOwogICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gZ3JhcGgudmlldy5zY2FsZTsKICAgICAgICAgICAgICAgIHZhciB4ID0gcHQueCAvIHNjYWxlIC0gdHIueDsKICAgICAgICAgICAgICAgIHZhciB5ID0gcHQueSAvIHNjYWxlIC0gdHIueTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgLy8gQ29udmVydHMgbG9jYWwgZW50aXR5IHRvIGdyYXBoIGNlbGwKICAgICAgICAgICAgICAgIGxldCBhZGRDZWxsVG9HcmFwaCA9IChpdGVtcyk9PnsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBncmFwaC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7CgogICAgICAgICAgICAgICAgICAgIHRyeXsKCiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLmdldE1vZGVsKCk7CiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBncmFwaC5nZXREZWZhdWx0UGFyZW50KCk7CgogICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goaXRlbXMsKHYpPT57CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjZWxsID0gZ3JhcGguZ2V0TW9kZWwoKS5nZXRDZWxsKHYuaWQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGwpewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJG1lc3NhZ2UoewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAiaW5mbyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICLlt7LmnInor6Xlrp7kvZMiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSB2Lmljb24gfHwgJ21hdHJpeCc7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5Y+v6K6+572u6buY6K6k5pi+56S65bGe5oCnCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9ICAnJzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5ewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdpbmRvdy5VUkxfUEFSQU1TX0dSQVBIKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHZbd2luZG93LlVSTF9QQVJBTVNfR1JBUEgudGl0bGVdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB2W3RoaXMubW9kZWwuZ3JhcGguZGVmYXVsdC50aXRsZV07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB2WyJpZCJdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IHRoaXMuaW1hZ2VSZW5kZXJIYW5kbGVyKHR5cGUpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ3JhcGguY29udHJvbC5pZkljb24pewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY2hlY2tJbWdFeGlzdHMoYCR7dHlwZX0ucG5nYCkpewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsID0gZ3JhcGguaW5zZXJ0VmVydGV4KHBhcmVudCwgdi5pZCwgbmFtZSwgeCwgeSwgNjAsIDYwLGBzaGFwZT1pbWFnZTtodG1sPTE7aW1hZ2U9JHtpbWFnZVVybH07dmVydGljYWxMYWJlbFBvc2l0aW9uPWJvdHRvbTt2ZXJ0aWNhbEFsaWduPXRvcDtgKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsID0gZ3JhcGguaW5zZXJ0VmVydGV4KHBhcmVudCwgdi5pZCwgbmFtZSwgeCwgeSwgNTAsIDUwLGBzaGFwZT1lbGxpcHNlO3BlcmltZXRlcj1lbGxpcHNlUGVyaW1ldGVyO2h0bWw9MTtsYWJlbFBvc2l0aW9uPWNlbnRlcjt2ZXJ0aWNhbExhYmVsUG9zaXRpb249Ym90dG9tO2FsaWduPWNlbnRlcjt2ZXJ0aWNhbEFsaWduPW1pZGRsZTtgKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNoYXBl5riy5p+TCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsID0gZ3JhcGguaW5zZXJ0VmVydGV4KHBhcmVudCwgdi5pZCwgbmFtZSwgeCwgeSwgNTAsIDUwLGBzaGFwZT1lbGxpcHNlO3BlcmltZXRlcj1lbGxpcHNlUGVyaW1ldGVyO2h0bWw9MTtsYWJlbFBvc2l0aW9uPWNlbnRlcjt2ZXJ0aWNhbExhYmVsUG9zaXRpb249Ym90dG9tO2FsaWduPWNlbnRlcjt2ZXJ0aWNhbEFsaWduPW1pZGRsZTtgKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDlrprkvY3liLBjZWxsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguc2Nyb2xsQ2VsbFRvVmlzaWJsZShjZWxsKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5zZXRTZWxlY3Rpb25DZWxsKGNlbGwpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwxMDAwKQoKICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpewogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7CiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoImNvbnRyb2wtc2hvdyIsZmFsc2UpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH07CiAgICAKICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IFtKU09OLnBhcnNlKGV2dC5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgiVGV4dCIpKV07CgogICAgICAgICAgICAgICAgYWRkQ2VsbFRvR3JhcGgoaXRlbXMpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgfSwKICAgIC8vIOa7mui9rue8qeaUvuS6i+S7tuebkeWQrAogICAgYWRkU2Nyb2xsTGlzdGVuZXIoZ3JhcGgpewogICAgICAgIHZhciB0ID0gKGZ1bmN0aW9uIGEoZWxlbWVudCwgd2hlZWxIYW5kbGUpIHsKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPSAnb2JqZWN0JykgcmV0dXJuOwogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aGVlbEhhbmRsZSAhPSAnZnVuY3Rpb24nKSByZXR1cm47CgogICAgICAgICAgICAgICAgLy8g55uR5rWL5rWP6KeI5ZmoCiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGEuYnJvd3NlciA9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgICAgICAgIHZhciB1c2VyID0gbmF2aWdhdG9yLnVzZXJBZ2VudDsKICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHt9OwogICAgICAgICAgICAgICAgICAgIGIub3BlcmEgPSB1c2VyLmluZGV4T2YoIk9wZXJhIikgPiAtMSAmJiB0eXBlb2Ygd2luZG93Lm9wZXJhID09ICJvYmplY3QiOwogICAgICAgICAgICAgICAgICAgIGIua2h0bWwgPSAodXNlci5pbmRleE9mKCJLSFRNTCIpID4gLTEgfHwgdXNlci5pbmRleE9mKCJBcHBsZVdlYktpdCIpID4gLTEgfHwgdXNlci5pbmRleE9mKCJLb25xdWVyb3IiKSA+IC0xKSAmJiAhYi5vcGVyYTsKICAgICAgICAgICAgICAgICAgICBiLmllID0gdXNlci5pbmRleE9mKCJNU0lFIikgPiAtMSAmJiAhYi5vcGVyYTsKICAgICAgICAgICAgICAgICAgICBiLmdlY2tvID0gdXNlci5pbmRleE9mKCJHZWNrbyIpID4gLTEgJiYgIWIua2h0bWw7CiAgICAgICAgICAgICAgICAgICAgYS5icm93c2VyID0gYjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09IHdpbmRvdykKICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQ7CiAgICAgICAgICAgICAgICBpZiAoYS5icm93c2VyLmllKQogICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ubW91c2V3aGVlbCcsIHdoZWVsSGFuZGxlKTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYS5icm93c2VyLmdlY2tvID8gJ0RPTU1vdXNlU2Nyb2xsJyA6ICdtb3VzZXdoZWVsJywgd2hlZWxIYW5kbGUsIGZhbHNlKTsKICAgICAgICB9KTsKICAgICAgICB0KGdyYXBoLmNvbnRhaW5lciwgdGhpcy53aGVlbEhhbmRsZSk7CiAgICB9LAogICAgLy8g5rua6L2u57yp5pS+5Zu+CiAgICB3aGVlbEhhbmRsZShlKSB7CiAgICAgICAgdmFyIHVwY2hlY2s7CgogICAgICAgIGlmIChlLndoZWVsRGVsdGEpIHsKICAgICAgICAgICAgdXBjaGVjayA9IGUud2hlZWxEZWx0YSA+IDAgPyAxIDogMDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB1cGNoZWNrID0gZS5kZXRhaWwgPCAwID8gMSA6IDA7CiAgICAgICAgfQogICAgICAgIGlmICh1cGNoZWNrKSB7CiAgICAgICAgICAgIHRoaXMuZ3JhcGguZWRpdG9yLmdyYXBoLnpvb21JbigpOwogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgICAgdGhpcy5ncmFwaC5lZGl0b3IuZ3JhcGguem9vbU91dCgpOwogICAgICAgIH0KCiAgICAgICAgaWYgKHdpbmRvdy5ldmVudCkgewogICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7CiAgICAgICAgICAgIHdpbmRvdy5ldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsKICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsKICAgICAgICB9CiAgICB9LAogICAgY2hlY2tJbWdFeGlzdHMoKXsKICAgICAgICAvL2xldCB0ZXJtID0ge3BhcmVudDoiL2Fzc2V0cy9pbWFnZXMvZW50aXR5L3BuZyIsIG5hbWU6bmFtZX07CiAgICAgICAgcmV0dXJuIHRydWU7Ly9mc0hhbmRsZXIuY2FsbEZzSlNjcmlwdCgiL21hdHJpeC9tM2dyYXBoL2NoZWNrSGF2ZUZpbGUuanMiLCBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkodGVybSkpKS5tZXNzYWdlOwogICAgfSwgIAogICAgLy8g5riy5p+T5Zu+54mH5p2l5rqQCiAgICBpbWFnZVJlbmRlckhhbmRsZXIoaWNvbikgewogICAgICAgIAogICAgICAgIGlmKF8uaW5jbHVkZXMoaWNvbiwnaHR0cDovLycpKXsKICAgICAgICAgICAgcmV0dXJuIGljb247CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGAvc3RhdGljL2Fzc2V0cy9pbWFnZXMvZW50aXR5L3BuZy8ke2ljb259LnBuZ2A7CiAgICAgICAgfQoKICAgIH0sCiAgICAvLyDliIfmjaLpooTop4gKICAgIG9uSW5pdE91dGxpbmUoZ3JhcGgpewogICAgICAgIG5ldyBteE91dGxpbmUoZ3JhcGgsIHRoaXMuJHJlZnMub3V0bGluZUNvbnRhaW5lcik7CiAgICB9LAogICAgb25Ub2dnbGVPdXRsaW5lKHZhbCl7CiAgICAgICAgdGhpcy5ncmFwaC5jb250cm9sLm91dGxpbmUuc2hvdyA9IHZhbDsKICAgIH0sCiAgICAvLyDoh6rliqjliLfmlrDmjqfliLYKICAgIG9uUmVmcmVzaENoYW5nZSh2YWwpewogICAgICAgIHRoaXMub25SZWZyZXNoQ2VsbFN0YXR1cygpOwogICAgICAgIHRoaXMuZ3JhcGguY29udHJvbC5yZWZyZXNoLmVuYWJsZSA9IHZhbDsKICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgiR1JBUEgtU1RBVFVTLUlGUkVGUkVTSCIsIHRoaXMuZ3JhcGguY29udHJvbC5yZWZyZXNoLmVuYWJsZSk7CiAgICB9LAogICAgLy8g5a6a5L2N5Zu+6IqC54K5CiAgICBvblBvc2l0aW9uKGlkLGhGbGFnLHZGbGFnKXsKICAgICAgICAgICAgICAgIAogICAgICAgIGxldCBlZGl0b3IgPSB0aGlzLmdyYXBoLmVkaXRvcjsgCiAgICAgICAgbGV0IGdyYXBoID0gZWRpdG9yLmdyYXBoOwogICAgICAgIGxldCBjZWxsID0gZ3JhcGguZ2V0TW9kZWwoKS5nZXRDZWxsKGlkKTsKCiAgICAgICAgdHJ5ewogICAgICAgICAgICAvLyDmgaLlpI3lm77lrp7pmYXlpKflsI8KICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUoImFjdHVhbFNpemUiKTsgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICBsZXQgY29udGFpbmVyVyA9IGdyYXBoLmNvbnRhaW5lci5jbGllbnRXaWR0aDsKICAgICAgICAgICAgbGV0IGNvbnRhaW5lckggPSBncmFwaC5jb250YWluZXIuY2xpZW50SGVpZ2h0OwogICAgICAgICAgICBsZXQgeCA9LWNlbGwuZ2VvbWV0cnkueCArICggY29udGFpbmVyVyAtIGNlbGwuZ2VvbWV0cnkud2lkdGgpIC8gMjsKICAgICAgICAgICAgbGV0IHkgPS1jZWxsLmdlb21ldHJ5LnkgKyAoIGNvbnRhaW5lckggLSBjZWxsLmdlb21ldHJ5LmhlaWdodCkgLyAyOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYoIGhGbGFnICl7CiAgICAgICAgICAgICAgICB4ID0geCAvIDI7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmKCB2RmxhZyApewogICAgICAgICAgICAgICAgeSA9IHkgLyAyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBncmFwaC5nZXRWaWV3KCkuc2V0VHJhbnNsYXRlKHgseSk7CiAgICAgICAgICAgIGdyYXBoLnNjcm9sbENlbGxUb1Zpc2libGUoY2VsbCk7CiAgICAgICAgICAgIGdyYXBoLnNldFNlbGVjdGlvbkNlbGxzKFtjZWxsXSk7CgogICAgICAgICAgICBfLmRlbGF5KCgpPT57CiAgICAgICAgICAgICAgICBsZXQgc3RhdGUgPSBncmFwaC52aWV3LmdldFN0YXRlKGNlbGwpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZih0aGlzLm1vZGVsLmNvbnRyb2wuaWZJY29uKXsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zaGFwZS5ub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJpbWFnZSIpWzBdLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnYW5pbWF0ZWQgZmxhc2gnKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2hhcGUubm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZWxsaXBzZSIpWzBdLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnYW5pbWF0ZWQgZmxhc2gnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSw1MDApCgogICAgICAgICAgICAvLyDpgInmi6noioLngrnnqoHlh7rmmL7npLoKICAgICAgICAgICAgZ3JhcGguc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9QRVJJTUVURVJfU1BBQ0lORywgOCwgW2NlbGxdKTsKICAgICAgICAgICAgCiAgICAgICAgfSBjYXRjaChlcnIpewogICAgICAgICAgICAKICAgICAgICAgICAgLy8g5b2T5YmN55S75biD5Lit5LiN5YyF5ZCr6K+l5a6e5L2TCiAgICAgICAgICAgIHRoaXMuJG1lc3NhZ2UoewogICAgICAgICAgICAgICAgdHlwZTogImluZm8iLAogICAgICAgICAgICAgICAgbWVzc2FnZTogIueUu+W4g+ayoeacieivpeWunuS9kyAiCiAgICAgICAgICAgIH0pCiAgICAgICAgfQogICAgICAgIAogICAgfSwKICAgIC8vIOWbvuiHqumAguW6lOW5tuWxheS4reaYvuekugogICAgb25HcmFwaFRvQ2VudGVyKGltbWVkaWF0ZSl7CiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7CgogICAgICAgIGxldCBlZGl0b3IgPSB0aGlzLmdyYXBoLmVkaXRvcjsKICAgICAgICBsZXQgZ3JhcGggPSBlZGl0b3IuZ3JhcGg7CiAgICAgICAgbGV0IHBhcmVudCA9IGdyYXBoLmdldERlZmF1bHRQYXJlbnQoKTsKICAgICAgICBsZXQgbGltaXQgPSAzMDsgIC8vIOW9k+WJjeeUu+W4g+iKgueCueaVsOmHj+mYiOWAvAogICAgICAgIGxldCB0b3BDZWxsID0gZ3JhcGguZmluZFRyZWVSb290cyhwYXJlbnQpWzBdOwogICAgICAgIAogICAgICAgIC8vIOiOt+WPluW9k+WJjemAieaLqeiKgueCuSAKICAgICAgICAvLyDpkojlr7nliqDovb3lrZDlm77nmoTlnLrmma8KICAgICAgICAvLyDmnIDpobblsYLoioLngrkgIGdyYXBoLmNlbnRlcih0cnVlLHRydWUsMCwwLjUpOwogICAgICAgIC8vIOWtkOiKgueCuSAgZ3JhcGguY2VudGVyKHRydWUsdHJ1ZSwwLjUsMC41KTsKICAgICAgICBsZXQgdG9DZW50ZXIgPSBmdW5jdGlvbigpewogICAgICAgICAgICBsZXQgc2VsZWN0aW9uQ2VsbCA9IGdyYXBoLmdldFNlbGVjdGlvbkNlbGwoKTsKICAgICAgICAgICAgbGV0IGFsbENlbGxzID0gZ3JhcGguZ2V0Q2hpbGRWZXJ0aWNlcyhwYXJlbnQpOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYoIGFsbENlbGxzLmxlbmd0aCA+IGxpbWl0KXsKICAgICAgICAgICAgICAgIC8vIOWbvuiHqumAguW6lAogICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUoImZpdCIpOwogICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUoImFjdHVhbFNpemUiKTsgCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAvLyDlm77lrp7pmYXlpKflsI8KICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKCJhY3R1YWxTaXplIik7IAogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyDmsqHmnInpgInmi6noioLngrkKICAgICAgICAgICAgaWYoIHNlbGVjdGlvbkNlbGwgPT0gbnVsbCApewogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBncmFwaC5jZW50ZXIodHJ1ZSx0cnVlLDAuNSwwLjUpOyAgLy8gbWlkZGxlLWNlbnRlcgoKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgLy8g6YCJ5oup5LqG5pyA6aG25bGC6IqC54K5CiAgICAgICAgICAgICAgICBpZiggc2VsZWN0aW9uQ2VsbCA9PSB0b3BDZWxsICl7CiAgICAgICAgICAgICAgICAgICAgZ3JhcGguY2VudGVyKHRydWUsdHJ1ZSwwLDAuNSk7IC8vIHRvcC1jZW50ZXIKICAgICAgICAgICAgICAgICAgICAvLyDlrprkvY3pgInmi6noioLngrkKICAgICAgICAgICAgICAgICAgICBzZWxmLm9uUG9zaXRpb24oc2VsZWN0aW9uQ2VsbC5nZXRJZCgpLCB0cnVlLCB0cnVlKTsKICAgICAgICAgICAgICAgIH0gCiAgICAgICAgICAgICAgICAvLyDpgInmi6nkuoblrZDoioLngrkKICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgIGdyYXBoLmNlbnRlcih0cnVlLHRydWUsMC41LDAuNSk7ICAvLyBtaWRkbGUtY2VudGVyCiAgICAgICAgICAgICAgICAgICAgLy8g5a6a5L2N6YCJ5oup6IqC54K5CiAgICAgICAgICAgICAgICAgICAgc2VsZi5vblBvc2l0aW9uKHNlbGVjdGlvbkNlbGwuZ2V0SWQoKSwgdHJ1ZSwgdHJ1ZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vZ3JhcGguY2xlYXJTZWxlY3Rpb24oKTsKICAgICAgICAgICAgCiAgICAgICAgfQoKICAgICAgICBpZihpbW1lZGlhdGUpewogICAgICAgICAgICBlZGl0b3IuZXhlY3V0ZSgiZml0Iik7CiAgICAgICAgICAgIHRvQ2VudGVyKCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbGV0IGxvYWRTdmcgPSBmdW5jdGlvbigpewogICAgICAgICAgICAgICAgdHJ5ewogICAgICAgICAgICAgICAgICAgIGxldCBydG4gPSBncmFwaC5nZXRDaGlsZEVkZ2VzKHBhcmVudCk7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgaWYoXy5zaXplKHJ0bikgPiAwKXsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKXsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmKGxvYWRTdmcoKSkgewogICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+ewogICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKCJmaXQiKTsKICAgICAgICAgICAgICAgICAgICB0b0NlbnRlcigpOwogICAgICAgICAgICAgICAgfSw1MDApCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvYWRTdmcsIDUwKTsKICAgICAgICAgICAgfSAgIAogICAgICAgIH0KICAgIH0sCiAgICBvblJlbG9hZCgpewogICAgICAgIHRyeXsKICAgICAgICAgICAgJCh0aGlzLiRyZWZzLmdyYXBoQ29udGFpbmVyLiRlbCkuZW1wdHkoKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIOa4heepugogICAgICAgICAgICB0aGlzLmdyYXBoLmVkaXRvci5leGVjdXRlKCJzZWxlY3RBbGwiKTsKICAgICAgICAgICAgdGhpcy5ncmFwaC5lZGl0b3IuZXhlY3V0ZSgiZGVsZXRlIik7CgogICAgICAgICAgICAvLyDph43mlrDliJ3lp4vljJYKICAgICAgICAgICAgdGhpcy5pbml0R3JhcGgoKTsKCiAgICAgICAgfSBjYXRjaChlcnIpewoKICAgICAgICAgICAgdGhpcy5pbml0R3JhcGgoKTsKCiAgICAgICAgfSBmaW5hbGx5ewogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmFwaCh0aGlzLmdyYXBoLmVkaXRvcik7CgogICAgICAgIH0KICAgIH0sCiAgICAvLyDlm77nu5jliLYKICAgIHJlbmRlckdyYXBoKGVkaXRvcil7CiAgICAgICAgCiAgICAgICAgbGV0IGdyYXBoID0gZWRpdG9yLmdyYXBoOwogICAgICAgIGxldCBtb2RlbCA9IGdyYXBoLmdldE1vZGVsKCk7CiAgICAgICAgbGV0IHBhcmVudCA9IGdyYXBoLmdldERlZmF1bHRQYXJlbnQoKTsKCiAgICAgICAgbW9kZWwuYmVnaW5VcGRhdGUoKTsKICAgICAgICAKICAgICAgICB0cnl7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgaWYoIV8uaXNFbXB0eSh3aW5kb3cuVVJMX1BBUkFNU19JVEVNKSkgewogICAgICAgICAgICAgICAgbGV0IGRvYyA9IG14VXRpbHMucGFyc2VYbWwodGhpcy5ncmFwaC5kYXRhKTsKICAgICAgICAgICAgICAgIGxldCBjb2RlYyA9IG5ldyBteENvZGVjKGRvYyk7CiAgICAgICAgICAgICAgICBjb2RlYy5kZWNvZGUoZG9jLmRvY3VtZW50RWxlbWVudCwgbW9kZWwpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGxldCBhbGxOb2RlcyA9IF8uY29uY2F0KFtdLHRoaXMuZ3JhcGguZGF0YS5ub2Rlcyk7CiAgICAgICAgICAgICAgICBsZXQgYWxsRWRnZXMgPSBfLmNvbmNhdChbXSx0aGlzLmdyYXBoLmRhdGEuZWRnZXMpOwoKICAgICAgICAgICAgICAgIGlmKCB0aGlzLmdyYXBoLmRhdGFbJ2RpZmYnXSAmJiAnYWRkJyBpbiB0aGlzLmdyYXBoLmRhdGFbJ2RpZmYnXSApewogICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzID0gXy5jb25jYXQoYWxsTm9kZXMsIHRoaXMuZ3JhcGguZGF0YS5kaWZmLmFkZC5ub2Rlcyk7CiAgICAgICAgICAgICAgICAgICAgYWxsRWRnZXMgPSBfLmNvbmNhdChhbGxFZGdlcywgdGhpcy5ncmFwaC5kYXRhLmRpZmYuYWRkLmVkZ2VzKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiggdGhpcy5ncmFwaC5kYXRhWydkaWZmJ10gJiYgJ2RlbCcgaW4gdGhpcy5ncmFwaC5kYXRhWydkaWZmJ10gKXsKICAgICAgICAgICAgICAgICAgICBhbGxOb2RlcyA9IF8uY29uY2F0KGFsbE5vZGVzLCB0aGlzLmdyYXBoLmRhdGEuZGlmZi5kZWwubm9kZXMpOwogICAgICAgICAgICAgICAgICAgIGFsbEVkZ2VzID0gXy5jb25jYXQoYWxsRWRnZXMsIHRoaXMuZ3JhcGguZGF0YS5kaWZmLmRlbC5lZGdlcyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgYWxsTm9kZXMgPSBfLnVuaXFCeShhbGxOb2RlcywnaWQnKTsKICAgICAgICAgICAgICAgIGFsbEVkZ2VzID0gXy51bmlxQnkoYWxsRWRnZXMsJ2lkJyk7IAogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAvLyDnu5jliLboioLngrkKICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhbGxOb2Rlcywodik9PnsKCiAgICAgICAgICAgICAgICAgICAgbGV0IF90eXBlID0gdi5faWNvbiB8fCAnbWF0cml4JzsKCiAgICAgICAgICAgICAgICAgICAgLy8g5Y+v6K6+572u6buY6K6k5pi+56S65bGe5oCnCiAgICAgICAgICAgICAgICAgICAgbGV0IF9uYW1lID0gICcnOwoKICAgICAgICAgICAgICAgICAgICB0cnl7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdpbmRvdy5VUkxfUEFSQU1TX0dSQVBIKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9uYW1lID0gdlt3aW5kb3cuVVJMX1BBUkFNU19HUkFQSC50aXRsZV07CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbmFtZSA9IHZbdGhpcy5tb2RlbC5ncmFwaC5kZWZhdWx0LnRpdGxlXTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKXsKICAgICAgICAgICAgICAgICAgICAgICAgX25hbWUgPSB2WyJpZCJdOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgLy8g6YCJ5oup6IqC54K55riy5p+T5qih5byP77yaaWNvbi9zaGFwZQogICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IHRoaXMuaW1hZ2VSZW5kZXJIYW5kbGVyKF90eXBlKTsKCiAgICAgICAgICAgICAgICAgICAgLy8gaWNvbua4suafkwogICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ3JhcGguY29udHJvbC5pZkljb24pewogICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNoZWNrSW1nRXhpc3RzKGAke190eXBlfS5wbmdgKSl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5pbnNlcnRWZXJ0ZXgocGFyZW50LCB2LmlkLCBfbmFtZSwgNTAsIDUwLCA2MCwgNjAsYHNoYXBlPWltYWdlO2h0bWw9MTtpbWFnZT0ke2ltYWdlVXJsfTt2ZXJ0aWNhbExhYmVsUG9zaXRpb249Ym90dG9tO3ZlcnRpY2FsQWxpZ249dG9wO2ApOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguaW5zZXJ0VmVydGV4KHBhcmVudCwgdi5pZCwgX25hbWUsIDUwLCA1MCwgNTAsIDUwLGBzaGFwZT1lbGxpcHNlO3BlcmltZXRlcj1lbGxpcHNlUGVyaW1ldGVyO2h0bWw9MTtsYWJlbFBvc2l0aW9uPWNlbnRlcjt2ZXJ0aWNhbExhYmVsUG9zaXRpb249Ym90dG9tO2FsaWduPWNlbnRlcjt2ZXJ0aWNhbEFsaWduPW1pZGRsZTtgKTsKICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAKICAgICAgICAgICAgICAgICAgICB9IAogICAgICAgICAgICAgICAgICAgIC8vIHNoYXBl5riy5p+TCiAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLmluc2VydFZlcnRleChwYXJlbnQsIHYuaWQsIF9uYW1lLCA1MCwgNTAsIDUwLCA1MCxgc2hhcGU9ZWxsaXBzZTtwZXJpbWV0ZXI9ZWxsaXBzZVBlcmltZXRlcjtodG1sPTE7bGFiZWxQb3NpdGlvbj1jZW50ZXI7dmVydGljYWxMYWJlbFBvc2l0aW9uPWJvdHRvbTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7YCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgLy8g57uY5Yi26L65CiAgICAgICAgICAgICAgICBfLmZvckVhY2goYWxsRWRnZXMsKGssaW5kZXgpPT57CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgbGV0IHNvdXJjZSA9IG1vZGVsLmdldENlbGwoay5zb3VyY2UpOwogICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBtb2RlbC5nZXRDZWxsKGsudGFyZ2V0KTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBsZXQgYmFzZUVkZ2VTdHlsZSA9IGBlZGdlU3R5bGU9JHt0aGlzLmdyYXBoLnN0eWxlLmVkZ2UudmFsdWUudGl0bGV9O2h0bWw9MTtyb3VuZGVkPTE7amV0dHlTaXplPWF1dG87b3J0aG9nb25hbExvb3A9MTtlbmRBcnJvdz1ibG9jaztlbmRGaWxsPTE7YDsKICAgICAgICAgICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gJyc7CgogICAgICAgICAgICAgICAgICAgIGlmKGsudHdvd2F5KXsKICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3N0YXJ0QXJyb3c9YmxvY2s7ZW5kQXJyb3c9YmxvY2s7ZW5kRmlsbD0xOyc7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvLyBlZGdl5Li6cGF0aOeahOagt+W8jwogICAgICAgICAgICAgICAgICAgIGlmKGsuY2xhc3MgPT09ICJwYXRoIil7CiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VFZGdlU3R5bGUgPSBgZWRnZVN0eWxlPSR7dGhpcy5ncmFwaC5zdHlsZS5lZGdlLnZhbHVlLnRpdGxlfTtvcnRob2dvbmFsTG9vcD0xO3N0cm9rZVdpZHRoPTE7ZGFzaGVkPTE7c3RhcnRGaWxsPTA7ZW5kQXJyb3c9bm9uZTtlbmRGaWxsPTA7c3RhcnRBcnJvdz1ub25lO29ydGhvZ29uYWw9MTtlbGJvdz12ZXJ0aWNhbDtgOwogICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3Ryb2tlQ29sb3IgPSB0aGlzLm1vZGVsLmdyYXBoLnBhdGguY29sb3JzW2luZGV4XSB8fCBfLnNhbXBsZSh0aGlzLmdyYXBoLnBhdGguY29sb3JzKTsKICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguaW5zZXJ0RWRnZShwYXJlbnQsIGsuaWQsIGsuY2xhc3MsIHNvdXJjZSwgdGFyZ2V0LCBiYXNlRWRnZVN0eWxlK2RpcmVjdGlvbitgc3Ryb2tlQ29sb3I9JHtzdHJva2VDb2xvcn1gKTsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVkZ2VOYW1lID0gXy5maW5kKHRoaXMuZ3JhcGguZWRnZXMubGlzdCx7bmFtZTprLmNsYXNzfSkucmVtZWR5OwogICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5pbnNlcnRFZGdlKHBhcmVudCwgay5pZCwgZWRnZU5hbWUsIHNvdXJjZSwgdGFyZ2V0LCBiYXNlRWRnZVN0eWxlK2RpcmVjdGlvbik7CiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpewogICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5pbnNlcnRFZGdlKHBhcmVudCwgay5pZCwgay5jbGFzcywgc291cmNlLCB0YXJnZXQsIGJhc2VFZGdlU3R5bGUrZGlyZWN0aW9uKTsKICAgICAgICAgICAgICAgICAgICB9IAogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIAogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgIH0KICAgICAgICBmaW5hbGx5IHsKICAgICAgICAgICAgCiAgICAgICAgICAgIG1vZGVsLmVuZFVwZGF0ZSgpOyAgICAKCiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZUxheW91dCgpOwoKICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+ewogICAgICAgICAgICAgICAgdGhpcy5vbkdyYXBoVG9DZW50ZXIodHJ1ZSk7CiAgICAgICAgICAgIH0sNTAwKQoKICAgICAgICB9CiAgICB9LAogICAgcmVuZGVyQW5kTWVyZ2VHcmFwaChlZGl0b3IpewogICAgICAgIAogICAgICAgIGxldCBncmFwaCA9IG5ldyBteEdyYXBoKCk7CiAgICAgICAgbGV0IHBhcmVudCA9IGdyYXBoLmdldERlZmF1bHRQYXJlbnQoKTsKICAgICAgICBsZXQgbW9kZWwgPSBncmFwaC5nZXRNb2RlbCgpOwoKICAgICAgICBtb2RlbC5iZWdpblVwZGF0ZSgpOwogICAgICAgIAogICAgICAgIHRyeXsKICAgICAgICAgICAgCgogICAgICAgICAgICBpZighXy5pc0VtcHR5KHdpbmRvdy5VUkxfUEFSQU1TX0lURU0pKSB7CiAgICAgICAgICAgICAgICBsZXQgZG9jID0gbXhVdGlscy5wYXJzZVhtbCh0aGlzLmdyYXBoLmRhdGEpOwogICAgICAgICAgICAgICAgbGV0IGNvZGVjID0gbmV3IG14Q29kZWMoZG9jKTsKICAgICAgICAgICAgICAgIGNvZGVjLmRlY29kZShkb2MuZG9jdW1lbnRFbGVtZW50LCBtb2RlbCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgbGV0IGFsbE5vZGVzID0gXy5jb25jYXQoW10sdGhpcy5ncmFwaC5kYXRhLm5vZGVzKTsKICAgICAgICAgICAgICAgIGxldCBhbGxFZGdlcyA9IF8uY29uY2F0KFtdLHRoaXMuZ3JhcGguZGF0YS5lZGdlcyk7CgogICAgICAgICAgICAgICAgaWYoIHRoaXMuZ3JhcGguZGF0YVsnZGlmZiddICYmICdhZGQnIGluIHRoaXMuZ3JhcGguZGF0YVsnZGlmZiddICl7CiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXMgPSBfLmNvbmNhdChhbGxOb2RlcywgdGhpcy5ncmFwaC5kYXRhLmRpZmYuYWRkLm5vZGVzKTsKICAgICAgICAgICAgICAgICAgICBhbGxFZGdlcyA9IF8uY29uY2F0KGFsbEVkZ2VzLCB0aGlzLmdyYXBoLmRhdGEuZGlmZi5hZGQuZWRnZXMpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmKCB0aGlzLmdyYXBoLmRhdGFbJ2RpZmYnXSAmJiAnZGVsJyBpbiB0aGlzLmdyYXBoLmRhdGFbJ2RpZmYnXSApewogICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzID0gXy5jb25jYXQoYWxsTm9kZXMsIHRoaXMuZ3JhcGguZGF0YS5kaWZmLmRlbC5ub2Rlcyk7CiAgICAgICAgICAgICAgICAgICAgYWxsRWRnZXMgPSBfLmNvbmNhdChhbGxFZGdlcywgdGhpcy5ncmFwaC5kYXRhLmRpZmYuZGVsLmVkZ2VzKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBhbGxOb2RlcyA9IF8udW5pcUJ5KGFsbE5vZGVzLCdpZCcpOwogICAgICAgICAgICAgICAgYWxsRWRnZXMgPSBfLnVuaXFCeShhbGxFZGdlcywnaWQnKTsgCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIC8vIOe7mOWItuiKgueCuQogICAgICAgICAgICAgICAgXy5mb3JFYWNoKGFsbE5vZGVzLCh2KT0+ewoKICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IHYuX2ljb24gfHwgJ21hdHJpeCc7CgogICAgICAgICAgICAgICAgICAgIC8vIOWPr+iuvue9rum7mOiupOaYvuekuuWxnuaApwogICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gICcnOwoKICAgICAgICAgICAgICAgICAgICB0cnl7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdpbmRvdy5VUkxfUEFSQU1TX0dSQVBIKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB2W3dpbmRvdy5VUkxfUEFSQU1TX0dSQVBILnRpdGxlXTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB2W3RoaXMubW9kZWwuZ3JhcGguZGVmYXVsdC50aXRsZV07CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGVycil7CiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSB2WyJpZCJdOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgLy8g6YCJ5oup6IqC54K55riy5p+T5qih5byP77yaaWNvbi9zaGFwZQogICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IHRoaXMuaW1hZ2VSZW5kZXJIYW5kbGVyKHR5cGUpOwoKICAgICAgICAgICAgICAgICAgICAvLyBpY29u5riy5p+TCiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5ncmFwaC5jb250cm9sLmlmSWNvbil7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY2hlY2tJbWdFeGlzdHMoYCR7dHlwZX0ucG5nYCkpewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguaW5zZXJ0VmVydGV4KHBhcmVudCwgdi5pZCwgbmFtZSwgNTAsIDUwLCA2MCwgNjAsYHNoYXBlPWltYWdlO2h0bWw9MTtpbWFnZT0ke2ltYWdlVXJsfTt2ZXJ0aWNhbExhYmVsUG9zaXRpb249Ym90dG9tO3ZlcnRpY2FsQWxpZ249dG9wO2ApOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguaW5zZXJ0VmVydGV4KHBhcmVudCwgdi5pZCwgbmFtZSwgNTAsIDUwLCA1MCwgNTAsYHNoYXBlPWVsbGlwc2U7cGVyaW1ldGVyPWVsbGlwc2VQZXJpbWV0ZXI7aHRtbD0xO2xhYmVsUG9zaXRpb249Y2VudGVyO3ZlcnRpY2FsTGFiZWxQb3NpdGlvbj1ib3R0b207YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO2ApOwogICAgICAgICAgICAgICAgICAgICAgICB9ICAgIAogICAgICAgICAgICAgICAgICAgIH0gCiAgICAgICAgICAgICAgICAgICAgLy8gc2hhcGXmuLLmn5MKICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguaW5zZXJ0VmVydGV4KHBhcmVudCwgdi5pZCwgbmFtZSwgNTAsIDUwLCA1MCwgNTAsYHNoYXBlPWVsbGlwc2U7cGVyaW1ldGVyPWVsbGlwc2VQZXJpbWV0ZXI7aHRtbD0xO2xhYmVsUG9zaXRpb249Y2VudGVyO3ZlcnRpY2FsTGFiZWxQb3NpdGlvbj1ib3R0b207YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO2ApOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIC8vIOe7mOWItui+uQogICAgICAgICAgICAgICAgXy5mb3JFYWNoKGFsbEVkZ2VzLChrLGluZGV4KT0+ewogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGxldCBzb3VyY2UgPSBtb2RlbC5nZXRDZWxsKGsuc291cmNlKTsKICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbW9kZWwuZ2V0Q2VsbChrLnRhcmdldCk7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgbGV0IGJhc2VFZGdlU3R5bGUgPSBgZWRnZVN0eWxlPSR7dGhpcy5ncmFwaC5zdHlsZS5lZGdlLnZhbHVlLnRpdGxlfTtodG1sPTE7cm91bmRlZD0xO2pldHR5U2l6ZT1hdXRvO29ydGhvZ29uYWxMb29wPTE7ZW5kQXJyb3c9YmxvY2s7ZW5kRmlsbD0xO2A7CiAgICAgICAgICAgICAgICAgICAgbGV0IGRpcmVjdGlvbiA9ICcnOwoKICAgICAgICAgICAgICAgICAgICBpZihrLnR3b3dheSl7CiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdzdGFydEFycm93PWJsb2NrO2VuZEFycm93PWJsb2NrO2VuZEZpbGw9MTsnOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgLy8gZWRnZeS4unBhdGjnmoTmoLflvI8KICAgICAgICAgICAgICAgICAgICBpZihrLmNsYXNzID09PSAicGF0aCIpewogICAgICAgICAgICAgICAgICAgICAgICBiYXNlRWRnZVN0eWxlID0gYGVkZ2VTdHlsZT0ke3RoaXMuZ3JhcGguc3R5bGUuZWRnZS52YWx1ZS50aXRsZX07b3J0aG9nb25hbExvb3A9MTtzdHJva2VXaWR0aD0xO2Rhc2hlZD0xO3N0YXJ0RmlsbD0wO2VuZEFycm93PW5vbmU7ZW5kRmlsbD0wO3N0YXJ0QXJyb3c9bm9uZTtvcnRob2dvbmFsPTE7ZWxib3c9dmVydGljYWw7YDsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0cm9rZUNvbG9yID0gdGhpcy5tb2RlbC5ncmFwaC5wYXRoLmNvbG9yc1tpbmRleF0gfHwgXy5zYW1wbGUodGhpcy5ncmFwaC5wYXRoLmNvbG9ycyk7CiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLmluc2VydEVkZ2UocGFyZW50LCBrLmlkLCBrLmNsYXNzLCBzb3VyY2UsIHRhcmdldCwgYmFzZUVkZ2VTdHlsZStkaXJlY3Rpb24rYHN0cm9rZUNvbG9yPSR7c3Ryb2tlQ29sb3J9YCk7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlZGdlTmFtZSA9IF8uZmluZCh0aGlzLmdyYXBoLmVkZ2VzLmxpc3Qse25hbWU6ay5jbGFzc30pLnJlbWVkeTsKICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguaW5zZXJ0RWRnZShwYXJlbnQsIGsuaWQsIGVkZ2VOYW1lLCBzb3VyY2UsIHRhcmdldCwgYmFzZUVkZ2VTdHlsZStkaXJlY3Rpb24pOwogICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKXsKICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGguaW5zZXJ0RWRnZShwYXJlbnQsIGsuaWQsIGsuY2xhc3MsIHNvdXJjZSwgdGFyZ2V0LCBiYXNlRWRnZVN0eWxlK2RpcmVjdGlvbik7CiAgICAgICAgICAgICAgICAgICAgfSAKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICB9CiAgICAgICAgZmluYWxseSB7CiAgICAgICAgICAgIAogICAgICAgICAgICBtb2RlbC5lbmRVcGRhdGUoKTsgICAgCgogICAgICAgICAgICAvLyDlkIjlubblm74KICAgICAgICAgICAgZWRpdG9yLmdyYXBoLmdldE1vZGVsKCkubWVyZ2VDaGlsZHJlbihtb2RlbC5nZXRSb290KCksIHBhcmVudCwgdHJ1ZSk7CgogICAgCiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZUxheW91dCgpOwoKICAgICAgICAgICAgdGhpcy5vbkdyYXBoVG9DZW50ZXIodHJ1ZSk7CgogICAgICAgIH0KICAgIH0sCiAgICAvLyDlm77liIbmnpAgLSDlrZDlm74KICAgIGxvYWRTdWJHcmFwaChub2RlKXsKCiAgICAgICAgbGV0IHRlcm0gPSAiIjsKICAgICAgICBsZXQgZWRnZVN0ciA9IF8uaXNFbXB0eShub2RlLmVkZ2UpID8gbm9kZS5lZGdlIDogYDoke25vZGUuZWRnZX1gOwoKICAgICAgICBpZihub2RlLmRpcmVjdGlvbj09Im91dCIpewogICAgICAgICAgICB0ZXJtID0gYG1hdGNoICgnJHtub2RlLm5vZGUuaWR9JykgLSBbJHtlZGdlU3RyfSoke25vZGUuc3RlcH1dIC0+ICgpYDsKICAgICAgICB9IGVsc2V7CiAgICAgICAgICAgIHRlcm0gPSBgbWF0Y2ggKCcke25vZGUubm9kZS5pZH0nKSA8LSBbJHtlZGdlU3RyfSoke25vZGUuc3RlcH1dIC0gKClgOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5tMy5jYWxsRlMoIi9tYXRyaXgvbTNncmFwaC9ncmFwaFNlcnZpY2UuanMiLCBlbmNvZGVVUklDb21wb25lbnQodGVybSkpLnRoZW4oIHJlcz0+ewogICAgICAgICAgICAKICAgICAgICAgICAgbGV0IHJ0biA9IHJlcy5tZXNzYWdlWzBdLmdyYXBoOwogICAgICAgICAgICBjb25zb2xlLmxvZygxMTExLHJ0bikKCiAgICAgICAgICAgIGxldCBhbGxOb2RlcyA9IF8uY29uY2F0KFtdLHJ0bi5ub2Rlcyk7CiAgICAgICAgICAgIGxldCBhbGxFZGdlcyA9IF8uY29uY2F0KFtdLHJ0bi5lZGdlcyk7CgogICAgICAgICAgICBpZiggcnRuWydkaWZmJ10gJiYgJ2FkZCcgaW4gcnRuWydkaWZmJ10gKXsKICAgICAgICAgICAgICAgIGFsbE5vZGVzID0gXy5jb25jYXQoYWxsTm9kZXMsIHJ0bi5kaWZmLmFkZC5ub2Rlcyk7CiAgICAgICAgICAgICAgICBhbGxFZGdlcyA9IF8uY29uY2F0KGFsbEVkZ2VzLCBydG4uZGlmZi5hZGQuZWRnZXMpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiggcnRuWydkaWZmJ10gJiYgJ2RlbCcgaW4gcnRuWydkaWZmJ10gKXsKICAgICAgICAgICAgICAgIGFsbE5vZGVzID0gXy5jb25jYXQoYWxsTm9kZXMsIHJ0bi5kaWZmLmRlbC5ub2Rlcyk7CiAgICAgICAgICAgICAgICBhbGxFZGdlcyA9IF8uY29uY2F0KGFsbEVkZ2VzLCBydG4uZGlmZi5kZWwuZWRnZXMpOwogICAgICAgICAgICB9CgogICAgICAgICAgICB0aGlzLmdyYXBoLmRhdGEubm9kZXMgPSBfLnVuaXFCeShhbGxOb2RlcywnaWQnKTsKICAgICAgICAgICAgdGhpcy5ncmFwaC5kYXRhLmVkZ2VzID0gXy51bmlxQnkoYWxsRWRnZXMsJ2lkJyk7CgogICAgICAgICAgICB0aGlzLnJlbmRlckFuZE1lcmdlR3JhcGgodGhpcy5ncmFwaC5lZGl0b3IpOwoKICAgICAgICB9ICk7CiAgICAgICAgCiAgICAgICAgCiAgICB9LAogICAgLy8g5Y+z6ZSu6I+c5Y2VCiAgICBjcmVhdGVQb3B1cE1lbnUoZWRpdG9yLCBncmFwaCwgbWVudSwgY2VsbCwgZXZ0KXsKICAgICAgICAKICAgICAgICAvLyDoioLngrnmiJbovrnoj5zljZUKICAgICAgICBpZiAoY2VsbCAhPSBudWxsKXsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIGNlbGwgb2JqZWN0CiAgICAgICAgICAgIGxldCBpZCA9IGNlbGwuZ2V0SWQoKTsKICAgICAgICAgICAgbGV0IHZhbHVlID0gY2VsbC5nZXRWYWx1ZSgpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8g6IqC54K56I+c5Y2VCiAgICAgICAgICAgIGlmKCFjZWxsLmVkZ2UpewogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZighdGhpcy5tMy5hdXRoLmlzQWRtaW4pIHJldHVybjsKCiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHtpZDogaWQsIHZhbHVlOiB2YWx1ZSwgdHlwZTonZXZlbnQnLCBjZWxsOiBjZWxsfTsKCiAgICAgICAgICAgICAgICAvKiBtZW51LmFkZEl0ZW0oJ+WunuS9k+WIhuaekCcsIG51bGwsICgpPT57CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB9KTsgKi8KCiAgICAgICAgICAgICAgICAvKiBtZW51LmFkZEl0ZW0oJ+WunuS9k+WIoOmZpCcsIG51bGwsICgpPT57CiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFbnRpdHlIYW5kbGVyKGNlbGwpOwogICAgICAgICAgICAgICAgfSk7ICovCgogICAgICAgICAgICAgICAgLy8gbWVudS5hZGRTZXBhcmF0b3IoKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgbWVudS5hZGRJdGVtKCfoioLngrnliKDpmaQnLCBudWxsLCAoKT0+ewogICAgICAgICAgICAgICAgICAgIHRoaXMub25EZWxldGVTZWxlY3RlZENlbGxzKGdyYXBoLGV2dCAhPSBudWxsICYmIG14RXZlbnQuaXNTaGlmdERvd24oZXZ0KSk7CiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBsZXQgdmFycyA9IHt9OwogICAgICAgICAgICAgICAgbGV0IHN1Ym1lbnVCc2VhcmNoID0gbnVsbDsKICAgICAgICAgICAgICAgIGxldCBzdWJtZW51RXNlYXJjaCA9IG51bGw7CiAgICAgICAgICAgICAgICB0aGlzLm0zLmNhbGxGUygiL21hdHJpeC9tM2dyYXBoL2dldEVkZ2VzQnlDbGFzcy5qcyIsZW5jb2RlVVJJQ29tcG9uZW50KGlkKSkudGhlbihydG49PnsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBtZW51LmFkZFNlcGFyYXRvcigpOwoKICAgICAgICAgICAgICAgICAgICBsZXQgZWRnZUxpc3RCeUNsYXNzID0gcnRuLm1lc3NhZ2U7CgogICAgICAgICAgICAgICAgICAgIGlmKF8uZmluZChlZGdlTGlzdEJ5Q2xhc3Mse2RpcmVjdGlvbjonb3V0J30pKXsKICAgICAgICAgICAgICAgICAgICAgICAgc3VibWVudUJzZWFyY2ggPSBtZW51LmFkZEl0ZW0oJ+i1t+eCueafpeivoicsIG51bGwsIG51bGwpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZihfLmZpbmQoZWRnZUxpc3RCeUNsYXNzLHtkaXJlY3Rpb246J2luJ30pKXsKICAgICAgICAgICAgICAgICAgICAgICAgc3VibWVudUVzZWFyY2ggPSBtZW51LmFkZEl0ZW0oJ+e7iOeCueafpeivoicsIG51bGwsIG51bGwpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goZWRnZUxpc3RCeUNsYXNzLCh2LGluZGV4KT0+ewogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgaWYodi5kaXJlY3Rpb24gPT0gJ291dCcpewogICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzWydzdWJtZW51QlN0ZXAnK2luZGV4XSA9IG1lbnUuYWRkSXRlbSh2LnJlbWVkeSxudWxsLG51bGwsc3VibWVudUJzZWFyY2gpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcENvdW50ID0gQXJyYXkoNik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goc3RlcENvdW50LCh2YWwsaWR4KT0+ewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaWR4ICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oc3RlcCArICfot7MnLCBudWxsLCAoKT0+ewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRTdWJHcmFwaCh7ZGlyZWN0aW9uOiJvdXQiLG5vZGU6bm9kZSxzdGVwOnN0ZXAsZWRnZTp2Lm5hbWV9KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LHZhcnNbJ3N1Ym1lbnVCU3RlcCcraW5kZXhdKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcnNbJ3N1Ym1lbnVFU3RlcCcraW5kZXhdID0gbWVudS5hZGRJdGVtKHYucmVtZWR5LG51bGwsbnVsbCxzdWJtZW51RXNlYXJjaCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcENvdW50ID0gQXJyYXkoNik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goc3RlcENvdW50LCh2YWwsaWR4KT0+ewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaWR4ICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oc3RlcCArICfot7MnLCBudWxsLCAoKT0+ewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRTdWJHcmFwaCh7ZGlyZWN0aW9uOiJpbiIsbm9kZTpub2RlLHN0ZXA6c3RlcCxlZGdlOnYubmFtZX0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sdmFyc1snc3VibWVudUVTdGVwJytpbmRleF0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICB9KQoKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGlmKCF0aGlzLm0zLmF1dGguaXNBZG1pbikgcmV0dXJuOwoKICAgICAgICAgICAgICAgIC8vIG5vZGUgPSB7aWQ6IGlkLCB2YWx1ZTogdmFsdWUsIHR5cGU6J2VkZ2UnLCBjZWxsOiBjZWxsfTsKCiAgICAgICAgICAgICAgICAvKiBtZW51LmFkZEl0ZW0oJ+WunuS9k+WFs+ezu+WIhuaekCcsIG51bGwsICgpPT57CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgn5a6e5L2T5YWz57O75Yig6ZmkJywgbnVsbCwgKCk9PnsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbWVudS5hZGRTZXBhcmF0b3IoKTsKCiAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oJ+aWsOW7uuWFs+ezu+exu+WeiycsIG51bGwsICgpPT57CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgn5pu05paw5YWz57O757G75Z6LJywgbnVsbCwgKCk9PnsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBtZW51LmFkZFNlcGFyYXRvcigpOwoKICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgn6ZqQ6JeP6L65JywgbnVsbCwgKCk9PnsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIH0pOyAqLwogICAgICAgICAgICB9CiAgICAgICAgfSAKICAgICAgICAvLyDnlLvluIPoj5zljZUKICAgICAgICBlbHNlIHsKCiAgICAgICAgICAgIGxldCBjZWxscyA9IHRoaXMuZ3JhcGguZWRpdG9yLmdyYXBoLmdldENoaWxkVmVydGljZXModGhpcy5ncmFwaC5lZGl0b3IuZ3JhcGguZ2V0RGVmYXVsdFBhcmVudCgpKQogICAgICAgICAgICBpZighXy5pc0VtcHR5KGNlbGxzKSl7CiAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oJ+a4heepuicsIG51bGwsICgpPT57CiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNhbnZhc0NsZWFyKCk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBtZW51LmFkZFNlcGFyYXRvcigpOwoKICAgICAgICAgICAgCiAgICAgICAgICAgIGxldCBzdWJtZW51TGF5b3V0ID0gbWVudS5hZGRJdGVtKCfluIPlsYAnLCBudWxsLCBudWxsKTsKCiAgICAgICAgICAgIGxldCBzdWJtZW51TGF5b3V0SGllcmFyY2hpY2FsID0gbWVudS5hZGRJdGVtKCfliIblsYLluIPlsYAnLCBudWxsLCBudWxsLHN1Ym1lbnVMYXlvdXQpOwogICAgICAgICAgICBtZW51LmFkZEl0ZW0oJ+S4iuS4iycsIG51bGwsICgpPT57CiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmxheW91dC5kZWZhdWx0ID0gJ2hpZXJhcmNoaWNhbF92ZXJ0aWNhbCc7CiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVMYXlvdXQoKTsKICAgICAgICAgICAgfSwgc3VibWVudUxheW91dEhpZXJhcmNoaWNhbCk7CiAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgn5bem5Y+zJywgbnVsbCwgKCk9PnsKICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgubGF5b3V0LmRlZmF1bHQgPSAnaGllcmFyY2hpY2FsX2hvcml6b250YWwnOwogICAgICAgICAgICAgICAgdGhpcy5leGVjdXRlTGF5b3V0KCk7CiAgICAgICAgICAgIH0sIHN1Ym1lbnVMYXlvdXRIaWVyYXJjaGljYWwpOwoKICAgICAgICAgICAgCiAgICAgICAgICAgIGxldCBzdWJtZW51TGF5b3V0VHJlZSA9IG1lbnUuYWRkSXRlbSgn5qCR5b2i5biD5bGAJywgbnVsbCwgbnVsbCxzdWJtZW51TGF5b3V0KTsKCiAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgn5LiK5LiLJywgbnVsbCwgKCk9PnsKICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgubGF5b3V0LmRlZmF1bHQgPSAndHJlZV92ZXJ0aWNhbCc7CiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVMYXlvdXQoKTsKICAgICAgICAgICAgfSwgc3VibWVudUxheW91dFRyZWUpOwogICAgICAgICAgICBtZW51LmFkZEl0ZW0oJ+W3puWPsycsIG51bGwsICgpPT57CiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmxheW91dC5kZWZhdWx0ID0gJ3RyZWVfaG9yaXpvbnRhbCc7CiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVMYXlvdXQoKTsKICAgICAgICAgICAgfSwgc3VibWVudUxheW91dFRyZWUpOwoKICAgICAgICAgICAgbWVudS5hZGRJdGVtKCfpmo/mnLrluIPlsYAnLCBudWxsLCAoKT0+ewogICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5sYXlvdXQuZGVmYXVsdCA9ICdvcmdhbmljJzsKICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZUxheW91dCgpOwogICAgICAgICAgICB9LCBzdWJtZW51TGF5b3V0KTsKICAgICAgICAgICAgbWVudS5hZGRJdGVtKCflnIblvaLluIPlsYAnLCBudWxsLCAoKT0+ewogICAgICAgICAgICAgICAgdGhpcy5ncmFwaC5sYXlvdXQuZGVmYXVsdCA9ICdjaXJjbGUnOwogICAgICAgICAgICAgICAgdGhpcy5leGVjdXRlTGF5b3V0KCk7CiAgICAgICAgICAgIH0sIHN1Ym1lbnVMYXlvdXQpOwoKICAgICAgICB9CiAgICAgICAgCiAgICB9LAogICAgLy8g6K6+572u5biD5bGACiAgICBleGVjdXRlTGF5b3V0KCl7CiAgICAgICAgbGV0IGdyYXBoID0gdGhpcy5ncmFwaC5lZGl0b3IuZ3JhcGg7CiAgICAgICAgbGV0IHBhcmVudCA9IGdyYXBoLmdldERlZmF1bHRQYXJlbnQoKTsKICAgICAgICBsZXQgbGF5b3V0ID0gdGhpcy5ncmFwaC5sYXlvdXQ7CiAgICAgICAgbGV0IG1vZGVsID0gZ3JhcGguZ2V0TW9kZWwoKTsKCiAgICAgICAgLy8g5biD5bGA5a6a5LmJCiAgICAgICAgaWYobGF5b3V0LmRlZmF1bHQgPT09ICdoaWVyYXJjaGljYWxfdmVydGljYWwnKXsKICAgICAgICAgICAgLy8gTGF5b3V0IGhpZXJhcmNoaWNhbAogICAgICAgICAgICBtb2RlbC5iZWdpblVwZGF0ZSgpOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgbGF5b3V0Lmluc3QgPSBuZXcgbXhIaWVyYXJjaGljYWxMYXlvdXQoZ3JhcGgsIG14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCk7CiAgICAgICAgICAgICAgICBsYXlvdXQuaW5zdC5lZGdlU3R5bGUgPSBsYXlvdXQuZWRnZVN0eWxlOwogICAgICAgICAgICAgICAgbGF5b3V0Lmluc3QuaW50cmFDZWxsU3BhY2luZyA9IDgwOwogICAgICAgICAgICAgICAgbGF5b3V0Lmluc3QuaW50ZXJSYW5rQ2VsbFNwYWNpbmcgPSA4MDsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgbGF5b3V0Lmluc3QuZXhlY3V0ZShwYXJlbnQsIG51bGwpOwoKICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgIGxldCBtb3JwaCA9IG5ldyBteE1vcnBoaW5nKGdyYXBoKTsgIAogICAgICAgICAgICAgICAgbW9ycGguYWRkTGlzdGVuZXIobXhFdmVudC5ET05FLCBmdW5jdGlvbigpeyAgCiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZW5kVXBkYXRlKCk7ICAKICAgICAgICAgICAgICAgIH0pOyAgCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBtb3JwaC5zdGFydEFuaW1hdGlvbigpOyAgCiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgfSBlbHNlIGlmKGxheW91dC5kZWZhdWx0ID09PSAnaGllcmFyY2hpY2FsX2hvcml6b250YWwnKXsKICAgICAgICAgICAgLy8gTGF5b3V0IGhpZXJhcmNoaWNhbAogICAgICAgICAgICBtb2RlbC5iZWdpblVwZGF0ZSgpOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgbGF5b3V0Lmluc3QgPSBuZXcgbXhIaWVyYXJjaGljYWxMYXlvdXQoZ3JhcGgsIG14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKTsKICAgICAgICAgICAgICAgIGxheW91dC5pbnN0LmVkZ2VTdHlsZSA9IGxheW91dC5lZGdlU3R5bGU7CiAgICAgICAgICAgICAgICBsYXlvdXQuaW5zdC5pbnRyYUNlbGxTcGFjaW5nID0gODA7CiAgICAgICAgICAgICAgICBsYXlvdXQuaW5zdC5pbnRlclJhbmtDZWxsU3BhY2luZyA9IDgwOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBsYXlvdXQuaW5zdC5leGVjdXRlKHBhcmVudCwgbnVsbCk7CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgICBsZXQgbW9ycGggPSBuZXcgbXhNb3JwaGluZyhncmFwaCk7ICAKICAgICAgICAgICAgICAgIG1vcnBoLmFkZExpc3RlbmVyKG14RXZlbnQuRE9ORSwgZnVuY3Rpb24oKXsgIAogICAgICAgICAgICAgICAgICAgIG1vZGVsLmVuZFVwZGF0ZSgpOyAgCiAgICAgICAgICAgICAgICB9KTsgIAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgbW9ycGguc3RhcnRBbmltYXRpb24oKTsgIAogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgIH0gZWxzZSBpZihsYXlvdXQuZGVmYXVsdCA9PT0gJ29yZ2FuaWMnKXsKICAgICAgICAgICAgLy8gTGF5b3V0IE9yZ2FuaWMKICAgICAgICAgICAgbW9kZWwuYmVnaW5VcGRhdGUoKTsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGxheW91dC5pbnN0ID0gbmV3IG14RmFzdE9yZ2FuaWNMYXlvdXQoZ3JhcGgpOwogICAgICAgICAgICAgICAgbGF5b3V0Lmluc3QuZm9yY2VDb25zdGFudCA9IDE0MDsKICAgICAgICAgICAgICAgIC8vbGF5b3V0Lmluc3QuZXhlY3V0ZShwYXJlbnQpOwoKICAgICAgICAgICAgICAgIGxheW91dC5pbnN0LmV4ZWN1dGUocGFyZW50LG51bGwpOwogICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgbW9kZWwuZW5kVXBkYXRlKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgfSBlbHNlIGlmKGxheW91dC5kZWZhdWx0ID09PSAndHJlZV92ZXJ0aWNhbCcpewogICAgICAgICAgICAvKiBMYXlvdXQgdHJlZSB2ZXJ0aWNhbCAqLwogICAgICAgICAgICBtb2RlbC5iZWdpblVwZGF0ZSgpOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgbGV0IHRtcCA9IGdyYXBoLmdldFNlbGVjdGlvbkNlbGwoKTsKICAgICAgICAgICAgICAgIGxldCByb290cyA9IG51bGw7CiAgICAgICAgICAgICAgICBsZXQgY2VsbHMgPSBbdG1wXTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKCB0bXAgPT0gbnVsbCB8fCBtb2RlbC5nZXRDaGlsZENvdW50KHRtcCkgPT0gMCApIHsKICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZ2V0RWRnZUNvdW50KHRtcCkgPT0gMCl7CiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RzID0gZ3JhcGguZmluZFRyZWVSb290cyhwYXJlbnQpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcm9vdHMgPSBncmFwaC5maW5kVHJlZVJvb3RzKHRtcCk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKCByb290cyAhPSBudWxsICYmIHJvb3RzLmxlbmd0aCA+IDAgKSB7CiAgICAgICAgICAgICAgICAgICAgY2VsbHMgPSByb290czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYoIGNlbGxzLmxlbmd0aCA+IDAgKSB7CiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNlbGxzLCh2KT0+ewogICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuaW5zdCA9IG5ldyBteENvbXBhY3RUcmVlTGF5b3V0KGdyYXBoLCBmYWxzZSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5pbnN0LmVkZ2VSb3V0aW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5pbnN0LmxldmVsRGlzdGFuY2UgPSAzMDsKICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Lmluc3QuZXhlY3V0ZShwYXJlbnQsIHYpOwogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgbGV0IG1vcnBoID0gbmV3IG14TW9ycGhpbmcoZ3JhcGgpOyAgCiAgICAgICAgICAgICAgICBtb3JwaC5hZGRMaXN0ZW5lcihteEV2ZW50LkRPTkUsIGZ1bmN0aW9uKCl7ICAKICAgICAgICAgICAgICAgICAgICBtb2RlbC5lbmRVcGRhdGUoKTsgIAogICAgICAgICAgICAgICAgfSk7ICAKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIG1vcnBoLnN0YXJ0QW5pbWF0aW9uKCk7ICAKICAgICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZihsYXlvdXQuZGVmYXVsdCA9PT0gJ3RyZWVfaG9yaXpvbnRhbCcpewogICAgICAgICAgICAvKiBMYXlvdXQgdHJlZSBob3Jpem9udGFsICovCiAgICAgICAgICAgIG1vZGVsLmJlZ2luVXBkYXRlKCk7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBsZXQgdG1wID0gZ3JhcGguZ2V0U2VsZWN0aW9uQ2VsbCgpOwogICAgICAgICAgICAgICAgbGV0IHJvb3RzID0gbnVsbDsKICAgICAgICAgICAgICAgIGxldCBjZWxscyA9IFt0bXBdOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiAodG1wID09IG51bGwgfHwgbW9kZWwuZ2V0Q2hpbGRDb3VudCh0bXApID09IDApewogICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5nZXRFZGdlQ291bnQodG1wKSA9PSAwKXsKICAgICAgICAgICAgICAgICAgICAgICAgcm9vdHMgPSBncmFwaC5maW5kVHJlZVJvb3RzKHBhcmVudCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByb290cyA9IGdyYXBoLmZpbmRUcmVlUm9vdHModG1wKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAocm9vdHMgIT0gbnVsbCAmJiByb290cy5sZW5ndGggPiAwKXsKICAgICAgICAgICAgICAgICAgICBjZWxscyA9IHJvb3RzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiggY2VsbHMubGVuZ3RoID4gMCApIHsKICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goY2VsbHMsKHYpPT57CiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5pbnN0ID0gbmV3IG14Q29tcGFjdFRyZWVMYXlvdXQoZ3JhcGgsIHRydWUpOwogICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuaW5zdC5lZGdlUm91dGluZyA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQuaW5zdC5sZXZlbERpc3RhbmNlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5pbnN0LmV4ZWN1dGUocGFyZW50LCB2KTsKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgICBsZXQgbW9ycGggPSBuZXcgbXhNb3JwaGluZyhncmFwaCk7ICAKICAgICAgICAgICAgICAgIG1vcnBoLmFkZExpc3RlbmVyKG14RXZlbnQuRE9ORSwgZnVuY3Rpb24oKXsgIAogICAgICAgICAgICAgICAgICAgIG1vZGVsLmVuZFVwZGF0ZSgpOyAgCiAgICAgICAgICAgICAgICB9KTsgIAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgbW9ycGguc3RhcnRBbmltYXRpb24oKTsgIAogICAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLyogTGF5b3V0IENpcmNsZSAqLwogICAgICAgICAgICBtb2RlbC5iZWdpblVwZGF0ZSgpOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgbGF5b3V0Lmluc3QgPSBuZXcgbXhDaXJjbGVMYXlvdXQoZ3JhcGgpOwogICAgICAgICAgICAgICAgbGF5b3V0Lmluc3QuZXhlY3V0ZShwYXJlbnQsIG51bGwpOwogICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgbW9kZWwuZW5kVXBkYXRlKCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgCiAgICB9LAogICAgLy8g6IqC54K55ZGK6K2m54q25oCBCiAgICBvblJlZnJlc2hDZWxsU3RhdHVzKCl7CiAgICAgICAgCiAgICAgICAgbGV0IGdyYXBoID0gdGhpcy5ncmFwaC5lZGl0b3IuZ3JhcGg7CiAgICAgICAgbGV0IHBhcmVudCA9IGdyYXBoLmdldERlZmF1bHRQYXJlbnQoKTsKICAgICAgICAKICAgICAgICAvLyDlm77miYDmnInoioLngrkKICAgICAgICBsZXQgY2VsbHMgPSBfLm1hcChncmFwaC5nZXRDaGlsZFZlcnRpY2VzKHBhcmVudCksdj0+ewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2dpZDogdi5pZCwgbmFtZTogdi52YWx1ZX07CiAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgIHRoaXMubTMuY2FsbEZTKCIvbWF0cml4L20zZ3JhcGgvZ3JhcGhfaW1hcF9kYXRhLmpzIiwgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNlbGxzKSkpLnRoZW4oIHJ0bj0+ewogICAgICAgICAgICAKICAgICAgICAgICAgZ3JhcGguZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpOwoKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgXy5mb3JFYWNoKHJ0bi5tZXNzYWdlLCh2KT0+ewogICAgICAgICAgICAgICAgICAgIGxldCBpZCA9IHYuZ2lkOwogICAgICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSB2LnN0YXR1czsKICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IGdyYXBoLmdldE1vZGVsKCkuZ2V0Q2VsbChpZCk7CiAgICAgICAgICAgICAgICAgICAgLy9sZXQgc3RhdGUgPSBncmFwaC52aWV3LmdldFN0YXRlKGNlbGwpOwogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGlmIChjZWxsICE9IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0cwogICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5yZW1vdmVDZWxsT3ZlcmxheXMoY2VsbCk7CgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID49IDUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLmFkZENlbGxPdmVybGF5KGNlbGwsIHRoaXMuY3JlYXRlT3ZlcmxheUJ5VGlwKHN0YXR1cywgYCR7aWR9OiDph43lpKflkYroraZgKSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID4zICYmIHN0YXR1cyA8IDUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLmFkZENlbGxPdmVybGF5KGNlbGwsIHRoaXMuY3JlYXRlT3ZlcmxheUJ5VGlwKHN0YXR1cywgYCR7aWR9OiDkuKXph43lkYroraZgKSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5yZW1vdmVDZWxsT3ZlcmxheXMoY2VsbCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIH0pCgogICAgICAgICAgICB9IAogICAgICAgICAgICBmaW5hbGx5IHsKICAgICAgICAgICAgICAgIGdyYXBoLmdldE1vZGVsKCkuZW5kVXBkYXRlKCk7CiAgICAgICAgICAgIH0KICAgICAgICB9ICk7CiAgICB9LAogICAgLy8g6IqC54K554q25oCB5riy5p+T5Zu+5qCHCiAgICBjcmVhdGVPdmVybGF5QnlUaXAoaW1hZ2UsIHRvb2x0aXApIHsgICAgICAgICAgICAgICAgICAKICAgICAgICBsZXQgb3ZlcmxheSA9IG5ldyBteENlbGxPdmVybGF5KG5ldyBteEltYWdlKGAvc3RhdGljL2Fzc2V0cy9pbWFnZXMvYXBwcy9wbmcvc2V2ZXJpdHkvJHtpbWFnZX0ucG5nYCwyNCwyNCksIHRvb2x0aXAsIG14Q29uc3RhbnRzLkFMSUdOX1JJR0hULCBteENvbnN0YW50cy5BTElHTl9UT1AsIG5ldyBteFBvaW50KC0xMCwxNSkpOwogICAgICAgIHJldHVybiBvdmVybGF5OwogICAgfSwKICAgIC8vIOWIoOmZpOmAieaLqeeahOiKgueCuQogICAgb25EZWxldGVTZWxlY3RlZENlbGxzKGdyYXBoLGluY2x1ZGVFZGdlcyl7CiAgICAgICAgLy8gQ2FuY2VscyBpbnRlcmFjdGl2ZSBvcGVyYXRpb25zCiAgICAgICAgZ3JhcGguZXNjYXBlKCk7CiAgICAgICAgdmFyIGNlbGxzID0gZ3JhcGguZ2V0RGVsZXRhYmxlQ2VsbHMoZ3JhcGguZ2V0U2VsZWN0aW9uQ2VsbHMoKSk7CiAgICAgICAgCiAgICAgICAgaWYgKGNlbGxzICE9IG51bGwgJiYgY2VsbHMubGVuZ3RoID4gMCl7CiAgICAgICAgICAgIHZhciBwYXJlbnRzID0gZ3JhcGgubW9kZWwuZ2V0UGFyZW50cyhjZWxscyk7CiAgICAgICAgICAgIGdyYXBoLnJlbW92ZUNlbGxzKGNlbGxzLCBpbmNsdWRlRWRnZXMpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gU2VsZWN0cyBwYXJlbnRzIGZvciBlYXNpZXIgZWRpdGluZyBvZiBncm91cHMKICAgICAgICAgICAgaWYgKHBhcmVudHMgIT0gbnVsbCl7CiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ID0gW107CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKyl7CiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYXBoLm1vZGVsLmNvbnRhaW5zKHBhcmVudHNbaV0pICYmCiAgICAgICAgICAgICAgICAgICAgICAgIChncmFwaC5tb2RlbC5pc1ZlcnRleChwYXJlbnRzW2ldKSB8fAogICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5tb2RlbC5pc0VkZ2UocGFyZW50c1tpXSkpKXsKICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0LnB1c2gocGFyZW50c1tpXSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbHMoc2VsZWN0KTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0sCiAgICAvLyDoioLngrnpq5jkuq7lrprkvY3mmL7npLoKICAgIG9uQ2VsbFBvc2l0aW9uKHJvdyxoRmxhZyx2RmxhZyl7CiAgICAgICAgCiAgICAgICAgbGV0IGlkID0gcm93LmVudGl0eTsKICAgICAgICBsZXQgZWRpdG9yID0gdGhpcy5ncmFwaC5lZGl0b3I7IAogICAgICAgIGxldCBncmFwaCA9IGVkaXRvci5ncmFwaDsKICAgICAgICBsZXQgY2VsbCA9IGdyYXBoLmdldE1vZGVsKCkuZ2V0Q2VsbChpZCk7CgogICAgICAgIHRyeXsKICAgICAgICAgICAgLy8g5qC55o2uY2VsbOaVsOmHj+WGs+WumuinhuWbvuaYr+WQpue8qeaUvgogICAgICAgICAgICBpZih0aGlzLmdyYXBoLmRhdGEubm9kZXMubGVuZ3RoID4gMTApewogICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUoImZpdCIpOyAgICAKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKCJhY3R1YWxTaXplIik7ICAKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgbGV0IGNvbnRhaW5lclcgPSBncmFwaC5jb250YWluZXIuY2xpZW50V2lkdGg7CiAgICAgICAgICAgIGxldCBjb250YWluZXJIID0gZ3JhcGguY29udGFpbmVyLmNsaWVudEhlaWdodDsKICAgICAgICAgICAgbGV0IHggPS1jZWxsLmdlb21ldHJ5LnggKyAoIGNvbnRhaW5lclcgLSBjZWxsLmdlb21ldHJ5LndpZHRoKSAvIDI7CiAgICAgICAgICAgIGxldCB5ID0tY2VsbC5nZW9tZXRyeS55ICsgKCBjb250YWluZXJIIC0gY2VsbC5nZW9tZXRyeS5oZWlnaHQpIC8gMjsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmKCBoRmxhZyApewogICAgICAgICAgICAgICAgeCA9IHggLyAyOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiggdkZsYWcgKXsKICAgICAgICAgICAgICAgIHkgPSB5IC8gMjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgZ3JhcGguZ2V0VmlldygpLnNldFRyYW5zbGF0ZSh4LHkpOwogICAgICAgICAgICBncmFwaC5zY3JvbGxDZWxsVG9WaXNpYmxlKGNlbGwpOwogICAgICAgICAgICBncmFwaC5zZXRTZWxlY3Rpb25DZWxscyhbY2VsbF0pOwoKICAgICAgICAgICAgXy5kZWxheSgoKT0+ewogICAgICAgICAgICAgICAgbGV0IHN0YXRlID0gZ3JhcGgudmlldy5nZXRTdGF0ZShjZWxsKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYodGhpcy5ncmFwaC5jb250cm9sLmlmSWNvbil7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2hhcGUubm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaW1hZ2UiKVswXS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2FuaW1hdGVkIGZsYXNoJyk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLnNoYXBlLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImVsbGlwc2UiKVswXS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2FuaW1hdGVkIGZsYXNoJyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sNTAwKQoKICAgICAgICAgICAgLy8g6YCJ5oup6IqC54K556qB5Ye65pi+56S6CiAgICAgICAgICAgIGdyYXBoLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfUEVSSU1FVEVSX1NQQUNJTkcsIDgsIFtjZWxsXSk7CiAgICAgICAgICAgIAogICAgICAgIH0gY2F0Y2goZXJyKXsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIOW9k+WJjeeUu+W4g+S4reS4jeWMheWQq+ivpeWunuS9kwogICAgICAgICAgICB0aGlzLiRtZXNzYWdlKHsKICAgICAgICAgICAgICAgIHR5cGU6ICJpbmZvIiwKICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICLmsqHmnInor6Xlrp7kvZMgIgogICAgICAgICAgICB9KQogICAgICAgIH0KICAgIH0sCiAgICAvLyDnlLvluIPmuIXnqboKICAgIG9uQ2FudmFzQ2xlYXIoKXsKICAgICAgICB0aGlzLmdyYXBoLmVkaXRvci5leGVjdXRlKCJzZWxlY3RBbGwiKTsKICAgICAgICB0aGlzLmdyYXBoLmVkaXRvci5leGVjdXRlKCJkZWxldGUiKTsKICAgIH0KICB9LAp9Owo="},{"version":3,"sources":["GraphHandler.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0EA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"GraphHandler.vue","sourceRoot":"src/components/graph","sourcesContent":["<template>\n\n  <el-container ref=\"container\">\n    <el-header style=\"height:40px;line-height:40px;padding:0px;text-align:right;\">\n        <el-popover\n            placement=\"left\"\n            trigger=\"click\"\n            popper-class=\"info-popper\">\n            <el-container>\n                <el-main style=\"padding:0px;\">\n                    <el-tabs value=\"setup\">\n                        <el-tab-pane label=\"设置\" name=\"setup\">\n                            <el-form>\n                                <el-form-item label=\"工具栏\">\n                                    <el-switch\n                                        v-model=\"graph.control.toolbar.show\"\n                                        active-color=\"#13ce66\"\n                                        inactive-color=\"#dddddd\">\n                                    </el-switch>\n                                </el-form-item>\n                                <el-form-item label=\"自动刷新\">\n                                    <el-switch\n                                        v-model=\"graph.control.refresh.enable\"\n                                        active-color=\"#13ce66\"\n                                        inactive-color=\"#dddddd\"\n                                        @change=\"onRefreshChange\">\n                                    </el-switch>\n                                </el-form-item>\n                                <el-form-item label=\"手动刷新\">\n                                    <el-button type=\"text\"><i class=\"el-icon-refresh\" @click=\"onRefreshCellStatus\"></i></el-button>\n                                </el-form-item>\n                                <el-form-item label=\"预览视图\">\n                                    <el-switch\n                                        v-model=\"graph.control.outline.show\"\n                                        active-color=\"#13ce66\"\n                                        inactive-color=\"#dddddd\"\n                                        @change=\"onToggleOutline\">\n                                    </el-switch>\n                                </el-form-item>\n                            </el-form>\n                        </el-tab-pane>\n                        <el-tab-pane label=\"节点\" name=\"vertex\">\n                            <el-form>\n                                <el-form-item label=\"排列\">\n                                    \n                                </el-form-item>\n                            </el-form>\n                        </el-tab-pane>\n                        <el-tab-pane label=\"边线\" name=\"edge\">\n                            <el-form>\n                                <el-form-item label=\"样式\">\n                                    \n                                </el-form-item>\n                            </el-form>\n                        </el-tab-pane>\n                    </el-tabs>\n                </el-main>\n            </el-container>\n            <el-button type=\"text\" slot=\"reference\">\n                <i class=\"el-icon-setting\" style=\"font-size:15px;margin:0 5px;\"></i>\n            </el-button>\n        </el-popover>\n    </el-header>\n    <el-main id=\"graphContainer\" ref=\"graphContainer\" style=\"width:100vw;height:100vh;min-width:100vw;position:releative;overflow:hidden;padding:0px;\"></el-main>\n    <div ref=\"outlineContainer\"\n        class=\"outlineContainer\"\n        v-show=\"graph.control.outline.show\"\n        draggable=\"true\">\n    </div>\n  </el-container>\n\n</template>\n\n<script>\nimport 'mxgraph/javascript/src/css/common.css';\n\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport mxgraph from './mxGraph.js';\nconst {mxEditor,mxGraph,mxConstants,mxPanningHandler,mxGraphHandler,mxGuide,mxEdgeHandler,mxClient,mxRectangleShape,mxRubberband,mxCellOverlay,mxOutline,mxImage,mxPoint,mxEdgeStyle,mxCellTracker,mxUtils,mxCodec,mxEvent,mxHierarchicalLayout,mxMorphing,mxFastOrganicLayout,mxCompactTreeLayout,mxCircleLayout} = mxgraph;\n\nexport default {\n  name: \"GraphView\",\n  props: {\n    graphData: Object,\n    global: Object\n  },\n  data() {\n    return {\n      graph: {\n            editor:null,\n            data: {\n                nodes: [],\n                edges: []\n            },\n            control:{\n                ifIcon: true,\n                outline: {\n                    show: true,\n                    inst: null\n                },\n                toolbar:{\n                    show: false\n                },\n                refresh:{\n                    inst: null,\n                    enable: false,\n                    interval: 15*1000\n                }\n            },\n            layout: {\n                default: 'hierarchical_vertical'\n            },\n            style: {\n                grid: {\n                    show: false\n                },\n                vertex:{\n                    align: {\n                        value: '',\n                        list: [\n                            {name: '左对齐', icon:'', value:'mxConstants.ALIGN_LEFT'},\n                            {name: '居中', icon:'', value:'mxConstants.ALIGN_CENTER'},\n                            {name: '右对齐', icon:'', value:'mxConstants.ALIGN_RIGHT'},\n                            {name: '上对齐', icon:'', value:'mxConstants.ALIGN_TOP'},\n                            {name: '中间', icon:'', value:'mxConstants.ALIGN_MIDDLE'},\n                            {name: '下对齐', icon:'', value:'mxConstants.ALIGN_BOTTOM'}\n                        ]\n                    }\n                },\n                edge: {\n                    endArrow: 'classic',\n                    strokeWidth: 1,\n                    strokeColor: '#333333',\n                    value: {\n                            name: 'isometric1', cnTitle:'等距1', title:'isometricEdgeStyle', keys:[mxConstants.STYLE_EDGE, mxConstants.STYLE_ELBOW, mxConstants.STYLE_CURVED, mxConstants.STYLE_NOEDGESTYLE], values:['isometricEdgeStyle', null, null, null]\n                        },\n                    list: [\n                        {\n                            name: 'straight', cnTitle:'直线', title:'isometricEdgeStyle', keys:[mxConstants.STYLE_EDGE, mxConstants.STYLE_CURVED, mxConstants.STYLE_NOEDGESTYLE], values:[null, null, null]\n                        },\n                        {\n                            name: 'orthogonal', cnTitle:'正交', title:'orthogonalEdgeStyle', keys:[mxConstants.STYLE_EDGE, mxConstants.STYLE_CURVED, mxConstants.STYLE_NOEDGESTYLE], values:['orthogonalEdgeStyle', null, null]\n                        },\n                        {\n                            name: 'simple1', cnTitle:'简单1', title:'elbowEdgeStyle', keys:[mxConstants.STYLE_EDGE, mxConstants.STYLE_ELBOW, mxConstants.STYLE_CURVED, mxConstants.STYLE_NOEDGESTYLE], values:['elbowEdgeStyle', null, null, null]\n                        },\n                        {\n                            name: 'simple2', cnTitle:'简单2', title:'elbowEdgeStyle', keys:[mxConstants.STYLE_EDGE, mxConstants.STYLE_ELBOW, mxConstants.STYLE_CURVED, mxConstants.STYLE_NOEDGESTYLE], values:['elbowEdgeStyle', 'vertical', null, null]\n                        },\n                        {\n                            name: 'isometric1', cnTitle:'等距1', title:'isometricEdgeStyle', keys:[mxConstants.STYLE_EDGE, mxConstants.STYLE_ELBOW, mxConstants.STYLE_CURVED, mxConstants.STYLE_NOEDGESTYLE], values:['isometricEdgeStyle', null, null, null]\n                        },\n                        {\n                            name: 'isometric2', cnTitle:'等距2', title:'isometricEdgeStyle', keys:[mxConstants.STYLE_EDGE, mxConstants.STYLE_ELBOW, mxConstants.STYLE_CURVED, mxConstants.STYLE_NOEDGESTYLE], values:['isometricEdgeStyle', 'vertical', null, null]\n                        },\n                        {\n                            name: 'entityRelation', cnTitle:'实体关联', title:'entityRelationEdgeStyle', keys:[mxConstants.STYLE_EDGE, mxConstants.STYLE_CURVED, mxConstants.STYLE_NOEDGESTYLE], values:['entityRelationEdgeStyle', null, null]\n                        }\n                    ]\n                }\n            },\n            path: {\n                list:[],\n                colors:['#ff0000','#ffd700','#666666','#00ffff','#40e0d0','#ff7373','#d3ffce','#3399ff','#000080','#66cccc','#a0db8e','#794044','#6897bb','#cc0000'],\n            },\n            edges: {\n                value: \"\",\n                list: [],\n                properties: {\n                    value: \"\",\n                    list: []\n                }\n            }\n      }\n    };\n  },\n  watch: {\n        graphData:{\n          handler(){\n              this.setGraphData();\n          },\n          immediate: true\n        },\n        'graph.control.refresh.enable':{\n            handler(val){\n                if(val) {\n                    this.graph.control.refresh.inst = setInterval(()=>{\n                        this.onRefreshCellStatus();\n                    },this.graph.control.refresh.interval);\n                    this.$message({\n                        type: \"info\",\n                        message: \"自动刷新开启\"\n                    })\n                } else {\n                    clearInterval(this.graph.control.refresh.inst);\n                    this.$message({\n                        type: \"info\",\n                        message: \"自动刷新关闭\"\n                    })\n                }\n            },\n            immediate:true\n        },\n  },\n  created(){\n    this.init();\n  },\n  mounted(){\n\n      this.initGraph();\n\n      this.eventHub.$on(\"graph-position\",(v)=>{\n          this.onCellPosition(v.row,v.hFlag,v.vFlag);\n      })\n\n  },\n  methods: {\n    // 初始化\n    init(){\n        this.m3.callFS(\"/matrix/m3graph/edges.js\",null).then( (rtn)=>{\n            this.graph.edges.list = rtn.message;\n        } );\n\n        // 状态刷新标志\n        this.graph.control.refresh.enable = (localStorage.getItem(\"GRAPH-STATUS-IFREFRESH\") == 'true');\n\n        // 节点是否可以移动 \n        mxGraphHandler.prototype.setMoveEnabled(true);\n        //显示节点位置标尺  \n        mxGraphHandler.prototype.guidesEnabled = true;\n\n        // Alt disables guides\n        mxGuide.prototype.isEnabledForEvent = function(evt){\n            return !mxEvent.isAltDown(evt);\n        };\n\n        // Enables snapping waypoints to terminals\n        mxEdgeHandler.prototype.snapToTerminals = true;\n\n    },\n    // 加载图数据\n    setGraphData(){\n        \n        if(_.isEmpty(this.graphData)) {\n            return false;\n        } else {\n            this.graph.data = this.graphData;\n            this.onReload();\n        }\n    },\n    // 初始化图板\n    initGraph(){\n        \n        this.graph.editor = new mxEditor();\n        this.graph.editor.setGraphContainer(this.$refs.graphContainer.$el);\n        let graph = this.graph.editor.graph;\n\n        // 是否允许平移。true：表示按住Shift+左键拖动时，整个graph移动；\n        // false：按住Shift+左键拖动时，选中的图形水平方向或者垂直方向平移。\n        graph.setPanning(true);\n        mxPanningHandler.prototype.isPanningTrigger = function() {\n            return true;\n        };\n\n        // 禁止改变节点大小\n        graph.setCellsResizable(false);\n        // 禁止节点文字编辑功能\n        graph.setCellsEditable(false);\n        \n        // 禁止连线移动\n        graph.disconnectOnMove = false;\n        \n\n        // 允许连线的目标和源是同一元素 \n        graph.setAllowLoops(true); \n        // 居中缩放\n        graph.centerZoom = true;\n        // Tooltips on touch devices\n        graph.setTooltips(!mxClient.IS_TOUCH);\n        // 支持Html\n        graph.setHtmlLabels(true);\n\n        // 去锯齿效果\n        mxRectangleShape.prototype.crisp = true;\n\n        // 鼠标框选\n        new mxRubberband(graph);\n        \n        // 预览时鼠标悬浮到节点时，改变鼠标样式\n        graph.getCursorForCell = function(cell){\n            if (cell != null && cell.value != null && cell.vertex ==1 ){\n                return 'pointer';\n            }\n        }\n        \n        // 预览时鼠标悬浮到节点时，改变节点样式\n        new mxCellTracker(graph);\n\n        // Sets global styles\n        var style = graph.getStylesheet().getDefaultEdgeStyle();\n        style[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;\n        style[mxConstants.STYLE_ROUNDED] = true;\n        style[mxConstants.EDGE_SELECTION_STROKEWIDTH] = 3;\n        style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR] = 'transparent';\n        style[mxConstants.STYLE_LABEL_PADDING] = 5;\n\n\n        style = graph.getStylesheet().getDefaultVertexStyle();\n        style[mxConstants.STYLE_FILLCOLOR] = '#2f8ee7';\n        style[mxConstants.STYLE_FONTCOLOR] = '#333333';\n        style[mxConstants.STYLE_FONTSIZE] = '14';\n        style[mxConstants.STYLE_SHAPE] = 'swimlane';\n        style[mxConstants.STYLE_SPACING] = '10';\n        style[mxConstants.STYLE_STARTSIZE] = 30;\n        style[mxConstants.STYLE_GRADIENTCOLOR] = '#419efe';\n        style[mxConstants.VERTEX_SELECTION_STROKEWIDTH] = 3;\n        style[mxConstants.VERTEX_SELECTION_COLOR] = '#ff0000';\n\n        // 预览时鼠标悬浮到节点时，改变节点样式\n        new mxCellTracker(graph);\n\n        // 首先禁用浏览器右键菜单\n        mxEvent.disableContextMenu(this.$el);\n        // 右键菜单\n        graph.popupMenuHandler.factoryMethod = (menu, cell, evt)=>{\n            this.createPopupMenu(this.graph.editor, graph, menu, cell, evt);\n        };\n\n        this.initGraphEvent(graph);\n\n    },\n    initGraphEvent(graph){\n        // 初始化滚轮图缩放事件监听\n        this.addScrollListener(graph);\n\n        // Add the source vertex\n        graph.addListener(mxEvent.ADD_CELLS, _.debounce(()=> {\n            this.onRefreshCellStatus();\n        }),1000);\n\n        // 初始化鹰眼视图\n        this.onInitOutline(graph);\n\n        // 监听拖拽事件\n        let container = this.$refs.graphContainer.$el;\n        mxEvent.addListener(container, 'dragover', (evt)=>{\n            if (graph.isEnabled()){\n                evt.stopPropagation();\n                evt.preventDefault();\n            }\n        });\n        // 监听拖入事件\n        mxEvent.addListener(container, 'drop', (evt)=>{\n            \n            if (graph.isEnabled()){\n                evt.stopPropagation();\n                evt.preventDefault();\n\n                // Gets drop location point for vertex\n                var pt = mxUtils.convertPoint(graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));\n                var tr = graph.view.translate;\n                var scale = graph.view.scale;\n                var x = pt.x / scale - tr.x;\n                var y = pt.y / scale - tr.y;\n                \n                // Converts local entity to graph cell\n                let addCellToGraph = (items)=>{\n                    \n                    graph.getModel().beginUpdate();\n\n                    try{\n\n                        graph.getModel();\n                        let parent = graph.getDefaultParent();\n\n                        _.forEach(items,(v)=>{\n                            \n                            let cell = graph.getModel().getCell(v.id);\n\n                            if(cell){\n                                this.$message({\n                                    type: \"info\",\n                                    message: \"已有该实体\"\n                                })\n                                return;\n                            }\n\n                            let type = v.icon || 'matrix';\n\n                            // 可设置默认显示属性\n                            let name =  '';\n                            \n                            try{\n                                if(window.URL_PARAMS_GRAPH){\n                                    name = v[window.URL_PARAMS_GRAPH.title];\n                                } else {\n                                    name = v[this.model.graph.default.title];\n                                }\n                            } catch(err){\n                                name = v[\"id\"];\n                            }\n\n                            let imageUrl = this.imageRenderHandler(type);\n\n                            if(this.graph.control.ifIcon){\n                                if(this.checkImgExists(`${type}.png`)){\n                                    cell = graph.insertVertex(parent, v.id, name, x, y, 60, 60,`shape=image;html=1;image=${imageUrl};verticalLabelPosition=bottom;verticalAlign=top;`);\n                                } else {\n                                    cell = graph.insertVertex(parent, v.id, name, x, y, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);\n                                }    \n                            } \n                            // shape渲染\n                            else {\n                                cell = graph.insertVertex(parent, v.id, name, x, y, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);\n                            }\n\n                            // 定位到cell\n                            setTimeout(()=>{\n                                graph.scrollCellToVisible(cell);\n                                graph.setSelectionCell(cell);\n                            },1000)\n\n                        })\n                    \n                        \n                    } catch(err){\n                        console.error(err);\n                    } finally {\n                        graph.getModel().endUpdate();\n\n                        this.$emit(\"control-show\",false);\n                    }\n                };\n    \n                var items = [JSON.parse(evt.dataTransfer.getData(\"Text\"))];\n\n                addCellToGraph(items);\n            }\n        });\n\n    },\n    // 滚轮缩放事件监听\n    addScrollListener(graph){\n        var t = (function a(element, wheelHandle) {\n                if (typeof element != 'object') return;\n                if (typeof wheelHandle != 'function') return;\n\n                // 监测浏览器\n                if (typeof a.browser == 'undefined') {\n                    var user = navigator.userAgent;\n                    var b = {};\n                    b.opera = user.indexOf(\"Opera\") > -1 && typeof window.opera == \"object\";\n                    b.khtml = (user.indexOf(\"KHTML\") > -1 || user.indexOf(\"AppleWebKit\") > -1 || user.indexOf(\"Konqueror\") > -1) && !b.opera;\n                    b.ie = user.indexOf(\"MSIE\") > -1 && !b.opera;\n                    b.gecko = user.indexOf(\"Gecko\") > -1 && !b.khtml;\n                    a.browser = b;\n                }\n                if (element == window)\n                    element = document;\n                if (a.browser.ie)\n                    element.attachEvent('onmousewheel', wheelHandle);\n                else\n                    element.addEventListener(a.browser.gecko ? 'DOMMouseScroll' : 'mousewheel', wheelHandle, false);\n        });\n        t(graph.container, this.wheelHandle);\n    },\n    // 滚轮缩放图\n    wheelHandle(e) {\n        var upcheck;\n\n        if (e.wheelDelta) {\n            upcheck = e.wheelDelta > 0 ? 1 : 0;\n        } else {\n            upcheck = e.detail < 0 ? 1 : 0;\n        }\n        if (upcheck) {\n            this.graph.editor.graph.zoomIn();\n        }\n        else {\n            this.graph.editor.graph.zoomOut();\n        }\n\n        if (window.event) {\n            e.returnValue = false;\n            window.event.cancelBubble = true;\n        } else {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n    },\n    checkImgExists(){\n        //let term = {parent:\"/assets/images/entity/png\", name:name};\n        return true;//fsHandler.callFsJScript(\"/matrix/m3graph/checkHaveFile.js\", encodeURIComponent(JSON.stringify(term))).message;\n    },  \n    // 渲染图片来源\n    imageRenderHandler(icon) {\n        \n        if(_.includes(icon,'http://')){\n            return icon;\n        } else {\n            return `/static/assets/images/entity/png/${icon}.png`;\n        }\n\n    },\n    // 切换预览\n    onInitOutline(graph){\n        new mxOutline(graph, this.$refs.outlineContainer);\n    },\n    onToggleOutline(val){\n        this.graph.control.outline.show = val;\n    },\n    // 自动刷新控制\n    onRefreshChange(val){\n        this.onRefreshCellStatus();\n        this.graph.control.refresh.enable = val;\n        localStorage.setItem(\"GRAPH-STATUS-IFREFRESH\", this.graph.control.refresh.enable);\n    },\n    // 定位图节点\n    onPosition(id,hFlag,vFlag){\n                \n        let editor = this.graph.editor; \n        let graph = editor.graph;\n        let cell = graph.getModel().getCell(id);\n\n        try{\n            // 恢复图实际大小\n            editor.execute(\"actualSize\");    \n            \n            let containerW = graph.container.clientWidth;\n            let containerH = graph.container.clientHeight;\n            let x =-cell.geometry.x + ( containerW - cell.geometry.width) / 2;\n            let y =-cell.geometry.y + ( containerH - cell.geometry.height) / 2;\n            \n            if( hFlag ){\n                x = x / 2;\n            }\n\n            if( vFlag ){\n                y = y / 2;\n            }\n            \n            graph.getView().setTranslate(x,y);\n            graph.scrollCellToVisible(cell);\n            graph.setSelectionCells([cell]);\n\n            _.delay(()=>{\n                let state = graph.view.getState(cell);\n                \n                if(this.model.control.ifIcon){\n                    state.shape.node.getElementsByTagName(\"image\")[0].setAttribute('class', 'animated flash');\n                } else {\n                    state.shape.node.getElementsByTagName(\"ellipse\")[0].setAttribute('class', 'animated flash');\n                }\n            },500)\n\n            // 选择节点突出显示\n            graph.setCellStyles(mxConstants.STYLE_PERIMETER_SPACING, 8, [cell]);\n            \n        } catch(err){\n            \n            // 当前画布中不包含该实体\n            this.$message({\n                type: \"info\",\n                message: \"画布没有该实体 \"\n            })\n        }\n        \n    },\n    // 图自适应并居中显示\n    onGraphToCenter(immediate){\n        const self = this;\n\n        let editor = this.graph.editor;\n        let graph = editor.graph;\n        let parent = graph.getDefaultParent();\n        let limit = 30;  // 当前画布节点数量阈值\n        let topCell = graph.findTreeRoots(parent)[0];\n        \n        // 获取当前选择节点 \n        // 针对加载子图的场景\n        // 最顶层节点  graph.center(true,true,0,0.5);\n        // 子节点  graph.center(true,true,0.5,0.5);\n        let toCenter = function(){\n            let selectionCell = graph.getSelectionCell();\n            let allCells = graph.getChildVertices(parent);\n            \n            if( allCells.length > limit){\n                // 图自适应\n                editor.execute(\"fit\");\n                editor.execute(\"actualSize\"); \n            } else {\n                // 图实际大小\n                editor.execute(\"actualSize\"); \n            }\n\n            // 没有选择节点\n            if( selectionCell == null ){\n                \n                graph.center(true,true,0.5,0.5);  // middle-center\n\n            } else {\n                \n                // 选择了最顶层节点\n                if( selectionCell == topCell ){\n                    graph.center(true,true,0,0.5); // top-center\n                    // 定位选择节点\n                    self.onPosition(selectionCell.getId(), true, true);\n                } \n                // 选择了子节点\n                else {\n                    graph.center(true,true,0.5,0.5);  // middle-center\n                    // 定位选择节点\n                    self.onPosition(selectionCell.getId(), true, true);\n                }\n            }\n\n            //graph.clearSelection();\n            \n        }\n\n        if(immediate){\n            editor.execute(\"fit\");\n            toCenter();\n        } else {\n            let loadSvg = function(){\n                try{\n                    let rtn = graph.getChildEdges(parent);\n                    \n                    if(_.size(rtn) > 0){\n                        return true;\n                    } else {\n                        return false;\n                    }\n                    \n                } catch(err){\n                    return false\n                }\n            };\n            \n            if(loadSvg()) {\n                setTimeout(()=>{\n                    editor.execute(\"fit\");\n                    toCenter();\n                },500)\n            } else {\n                setTimeout(loadSvg, 50);\n            }   \n        }\n    },\n    onReload(){\n        try{\n            $(this.$refs.graphContainer.$el).empty();\n            \n            // 清空\n            this.graph.editor.execute(\"selectAll\");\n            this.graph.editor.execute(\"delete\");\n\n            // 重新初始化\n            this.initGraph();\n\n        } catch(err){\n\n            this.initGraph();\n\n        } finally{\n            \n            this.renderGraph(this.graph.editor);\n\n        }\n    },\n    // 图绘制\n    renderGraph(editor){\n        \n        let graph = editor.graph;\n        let model = graph.getModel();\n        let parent = graph.getDefaultParent();\n\n        model.beginUpdate();\n        \n        try{\n            \n\n            if(!_.isEmpty(window.URL_PARAMS_ITEM)) {\n                let doc = mxUtils.parseXml(this.graph.data);\n                let codec = new mxCodec(doc);\n                codec.decode(doc.documentElement, model);\n            } else {\n                \n                \n                let allNodes = _.concat([],this.graph.data.nodes);\n                let allEdges = _.concat([],this.graph.data.edges);\n\n                if( this.graph.data['diff'] && 'add' in this.graph.data['diff'] ){\n                    allNodes = _.concat(allNodes, this.graph.data.diff.add.nodes);\n                    allEdges = _.concat(allEdges, this.graph.data.diff.add.edges);\n                }\n\n                if( this.graph.data['diff'] && 'del' in this.graph.data['diff'] ){\n                    allNodes = _.concat(allNodes, this.graph.data.diff.del.nodes);\n                    allEdges = _.concat(allEdges, this.graph.data.diff.del.edges);\n                }\n\n                allNodes = _.uniqBy(allNodes,'id');\n                allEdges = _.uniqBy(allEdges,'id'); \n                \n                // 绘制节点\n                _.forEach(allNodes,(v)=>{\n\n                    let _type = v._icon || 'matrix';\n\n                    // 可设置默认显示属性\n                    let _name =  '';\n\n                    try{\n                        if(window.URL_PARAMS_GRAPH){\n                            _name = v[window.URL_PARAMS_GRAPH.title];\n                        } else {\n                            _name = v[this.model.graph.default.title];\n                        }\n                    } catch(err){\n                        _name = v[\"id\"];\n                    }\n\n                    // 选择节点渲染模式：icon/shape\n                    let imageUrl = this.imageRenderHandler(_type);\n\n                    // icon渲染\n                    if(this.graph.control.ifIcon){\n                        if(this.checkImgExists(`${_type}.png`)){\n                            graph.insertVertex(parent, v.id, _name, 50, 50, 60, 60,`shape=image;html=1;image=${imageUrl};verticalLabelPosition=bottom;verticalAlign=top;`);\n                        } else {\n                            graph.insertVertex(parent, v.id, _name, 50, 50, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);\n                        }    \n                    } \n                    // shape渲染\n                    else {\n                        graph.insertVertex(parent, v.id, _name, 50, 50, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);\n                    }\n                })\n                \n                // 绘制边\n                _.forEach(allEdges,(k,index)=>{\n                    \n                    let source = model.getCell(k.source);\n                    let target = model.getCell(k.target);\n                    \n                    let baseEdgeStyle = `edgeStyle=${this.graph.style.edge.value.title};html=1;rounded=1;jettySize=auto;orthogonalLoop=1;endArrow=block;endFill=1;`;\n                    let direction = '';\n\n                    if(k.twoway){\n                        direction = 'startArrow=block;endArrow=block;endFill=1;';\n                    }\n\n                    // edge为path的样式\n                    if(k.class === \"path\"){\n                        baseEdgeStyle = `edgeStyle=${this.graph.style.edge.value.title};orthogonalLoop=1;strokeWidth=1;dashed=1;startFill=0;endArrow=none;endFill=0;startArrow=none;orthogonal=1;elbow=vertical;`;\n                        let strokeColor = this.model.graph.path.colors[index] || _.sample(this.graph.path.colors);\n                        graph.insertEdge(parent, k.id, k.class, source, target, baseEdgeStyle+direction+`strokeColor=${strokeColor}`);\n                        return;\n                    }\n\n                    \n                    try {\n                        let edgeName = _.find(this.graph.edges.list,{name:k.class}).remedy;\n                        graph.insertEdge(parent, k.id, edgeName, source, target, baseEdgeStyle+direction);\n                    } catch(err){\n                        graph.insertEdge(parent, k.id, k.class, source, target, baseEdgeStyle+direction);\n                    } \n                })\n                \n            }\n            \n        }\n        finally {\n            \n            model.endUpdate();    \n\n            this.executeLayout();\n\n            setTimeout(()=>{\n                this.onGraphToCenter(true);\n            },500)\n\n        }\n    },\n    renderAndMergeGraph(editor){\n        \n        let graph = new mxGraph();\n        let parent = graph.getDefaultParent();\n        let model = graph.getModel();\n\n        model.beginUpdate();\n        \n        try{\n            \n\n            if(!_.isEmpty(window.URL_PARAMS_ITEM)) {\n                let doc = mxUtils.parseXml(this.graph.data);\n                let codec = new mxCodec(doc);\n                codec.decode(doc.documentElement, model);\n            } else {\n                \n                \n                let allNodes = _.concat([],this.graph.data.nodes);\n                let allEdges = _.concat([],this.graph.data.edges);\n\n                if( this.graph.data['diff'] && 'add' in this.graph.data['diff'] ){\n                    allNodes = _.concat(allNodes, this.graph.data.diff.add.nodes);\n                    allEdges = _.concat(allEdges, this.graph.data.diff.add.edges);\n                }\n\n                if( this.graph.data['diff'] && 'del' in this.graph.data['diff'] ){\n                    allNodes = _.concat(allNodes, this.graph.data.diff.del.nodes);\n                    allEdges = _.concat(allEdges, this.graph.data.diff.del.edges);\n                }\n\n                allNodes = _.uniqBy(allNodes,'id');\n                allEdges = _.uniqBy(allEdges,'id'); \n                \n                // 绘制节点\n                _.forEach(allNodes,(v)=>{\n\n                    let type = v._icon || 'matrix';\n\n                    // 可设置默认显示属性\n                    let name =  '';\n\n                    try{\n                        if(window.URL_PARAMS_GRAPH){\n                            name = v[window.URL_PARAMS_GRAPH.title];\n                        } else {\n                            name = v[this.model.graph.default.title];\n                        }\n                    } catch(err){\n                        name = v[\"id\"];\n                    }\n\n                    // 选择节点渲染模式：icon/shape\n                    let imageUrl = this.imageRenderHandler(type);\n\n                    // icon渲染\n                    if(this.graph.control.ifIcon){\n                        if(this.checkImgExists(`${type}.png`)){\n                            graph.insertVertex(parent, v.id, name, 50, 50, 60, 60,`shape=image;html=1;image=${imageUrl};verticalLabelPosition=bottom;verticalAlign=top;`);\n                        } else {\n                            graph.insertVertex(parent, v.id, name, 50, 50, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);\n                        }    \n                    } \n                    // shape渲染\n                    else {\n                        graph.insertVertex(parent, v.id, name, 50, 50, 50, 50,`shape=ellipse;perimeter=ellipsePerimeter;html=1;labelPosition=center;verticalLabelPosition=bottom;align=center;verticalAlign=middle;`);\n                    }\n                })\n                \n                // 绘制边\n                _.forEach(allEdges,(k,index)=>{\n                    \n                    let source = model.getCell(k.source);\n                    let target = model.getCell(k.target);\n                    \n                    let baseEdgeStyle = `edgeStyle=${this.graph.style.edge.value.title};html=1;rounded=1;jettySize=auto;orthogonalLoop=1;endArrow=block;endFill=1;`;\n                    let direction = '';\n\n                    if(k.twoway){\n                        direction = 'startArrow=block;endArrow=block;endFill=1;';\n                    }\n\n                    // edge为path的样式\n                    if(k.class === \"path\"){\n                        baseEdgeStyle = `edgeStyle=${this.graph.style.edge.value.title};orthogonalLoop=1;strokeWidth=1;dashed=1;startFill=0;endArrow=none;endFill=0;startArrow=none;orthogonal=1;elbow=vertical;`;\n                        let strokeColor = this.model.graph.path.colors[index] || _.sample(this.graph.path.colors);\n                        graph.insertEdge(parent, k.id, k.class, source, target, baseEdgeStyle+direction+`strokeColor=${strokeColor}`);\n                        return;\n                    }\n\n                    \n                    try {\n                        let edgeName = _.find(this.graph.edges.list,{name:k.class}).remedy;\n                        graph.insertEdge(parent, k.id, edgeName, source, target, baseEdgeStyle+direction);\n                    } catch(err){\n                        graph.insertEdge(parent, k.id, k.class, source, target, baseEdgeStyle+direction);\n                    } \n                })\n                \n            }\n            \n        }\n        finally {\n            \n            model.endUpdate();    \n\n            // 合并图\n            editor.graph.getModel().mergeChildren(model.getRoot(), parent, true);\n\n    \n            this.executeLayout();\n\n            this.onGraphToCenter(true);\n\n        }\n    },\n    // 图分析 - 子图\n    loadSubGraph(node){\n\n        let term = \"\";\n        let edgeStr = _.isEmpty(node.edge) ? node.edge : `:${node.edge}`;\n\n        if(node.direction==\"out\"){\n            term = `match ('${node.node.id}') - [${edgeStr}*${node.step}] -> ()`;\n        } else{\n            term = `match ('${node.node.id}') <- [${edgeStr}*${node.step}] - ()`;\n        }\n\n        this.m3.callFS(\"/matrix/m3graph/graphService.js\", encodeURIComponent(term)).then( res=>{\n            \n            let rtn = res.message[0].graph;\n            console.log(1111,rtn)\n\n            let allNodes = _.concat([],rtn.nodes);\n            let allEdges = _.concat([],rtn.edges);\n\n            if( rtn['diff'] && 'add' in rtn['diff'] ){\n                allNodes = _.concat(allNodes, rtn.diff.add.nodes);\n                allEdges = _.concat(allEdges, rtn.diff.add.edges);\n            }\n\n            if( rtn['diff'] && 'del' in rtn['diff'] ){\n                allNodes = _.concat(allNodes, rtn.diff.del.nodes);\n                allEdges = _.concat(allEdges, rtn.diff.del.edges);\n            }\n\n            this.graph.data.nodes = _.uniqBy(allNodes,'id');\n            this.graph.data.edges = _.uniqBy(allEdges,'id');\n\n            this.renderAndMergeGraph(this.graph.editor);\n\n        } );\n        \n        \n    },\n    // 右键菜单\n    createPopupMenu(editor, graph, menu, cell, evt){\n        \n        // 节点或边菜单\n        if (cell != null){\n            \n            // cell object\n            let id = cell.getId();\n            let value = cell.getValue();\n            \n            // 节点菜单\n            if(!cell.edge){\n                \n                if(!this.m3.auth.isAdmin) return;\n\n                let node = {id: id, value: value, type:'event', cell: cell};\n\n                /* menu.addItem('实体分析', null, ()=>{\n                    \n                }); */\n\n                /* menu.addItem('实体删除', null, ()=>{\n                    this.removeEntityHandler(cell);\n                }); */\n\n                // menu.addSeparator();\n                \n                menu.addItem('节点删除', null, ()=>{\n                    this.onDeleteSelectedCells(graph,evt != null && mxEvent.isShiftDown(evt));\n                });\n\n                let vars = {};\n                let submenuBsearch = null;\n                let submenuEsearch = null;\n                this.m3.callFS(\"/matrix/m3graph/getEdgesByClass.js\",encodeURIComponent(id)).then(rtn=>{\n                    \n                    menu.addSeparator();\n\n                    let edgeListByClass = rtn.message;\n\n                    if(_.find(edgeListByClass,{direction:'out'})){\n                        submenuBsearch = menu.addItem('起点查询', null, null);\n                    }\n                    if(_.find(edgeListByClass,{direction:'in'})){\n                        submenuEsearch = menu.addItem('终点查询', null, null);\n                    }\n                    _.forEach(edgeListByClass,(v,index)=>{\n                        \n                        if(v.direction == 'out'){\n                            \n                            vars['submenuBStep'+index] = menu.addItem(v.remedy,null,null,submenuBsearch)\n                            let stepCount = Array(6);\n                            _.forEach(stepCount,(val,idx)=>{\n                                let step = idx + 1;\n                                \n                                menu.addItem(step + '跳', null, ()=>{\n                                    this.loadSubGraph({direction:\"out\",node:node,step:step,edge:v.name});\n                                },vars['submenuBStep'+index]);\n                            \n                            })\n                        } else {\n                            vars['submenuEStep'+index] = menu.addItem(v.remedy,null,null,submenuEsearch);\n                            let stepCount = Array(6);\n                            _.forEach(stepCount,(val,idx)=>{\n                                let step = idx + 1;\n                                \n                                menu.addItem(step + '跳', null, ()=>{\n                                    this.loadSubGraph({direction:\"in\",node:node,step:step,edge:v.name});\n                                },vars['submenuEStep'+index]);\n                                \n                            })\n                        }\n                        \n                    })\n\n                })\n                    \n                \n\n            } else {\n                \n                if(!this.m3.auth.isAdmin) return;\n\n                // node = {id: id, value: value, type:'edge', cell: cell};\n\n                /* menu.addItem('实体关系分析', null, ()=>{\n                    \n                });\n                menu.addItem('实体关系删除', null, ()=>{\n                    \n                });\n                menu.addSeparator();\n\n                menu.addItem('新建关系类型', null, ()=>{\n                    \n                });\n                menu.addItem('更新关系类型', null, ()=>{\n                    \n                });\n                \n                menu.addSeparator();\n\n                menu.addItem('隐藏边', null, ()=>{\n                    \n                }); */\n            }\n        } \n        // 画布菜单\n        else {\n\n            let cells = this.graph.editor.graph.getChildVertices(this.graph.editor.graph.getDefaultParent())\n            if(!_.isEmpty(cells)){\n                menu.addItem('清空', null, ()=>{\n                    this.onCanvasClear();\n                });\n            }\n            menu.addSeparator();\n\n            \n            let submenuLayout = menu.addItem('布局', null, null);\n\n            let submenuLayoutHierarchical = menu.addItem('分层布局', null, null,submenuLayout);\n            menu.addItem('上下', null, ()=>{\n                this.graph.layout.default = 'hierarchical_vertical';\n                this.executeLayout();\n            }, submenuLayoutHierarchical);\n            menu.addItem('左右', null, ()=>{\n                this.graph.layout.default = 'hierarchical_horizontal';\n                this.executeLayout();\n            }, submenuLayoutHierarchical);\n\n            \n            let submenuLayoutTree = menu.addItem('树形布局', null, null,submenuLayout);\n\n            menu.addItem('上下', null, ()=>{\n                this.graph.layout.default = 'tree_vertical';\n                this.executeLayout();\n            }, submenuLayoutTree);\n            menu.addItem('左右', null, ()=>{\n                this.graph.layout.default = 'tree_horizontal';\n                this.executeLayout();\n            }, submenuLayoutTree);\n\n            menu.addItem('随机布局', null, ()=>{\n                this.graph.layout.default = 'organic';\n                this.executeLayout();\n            }, submenuLayout);\n            menu.addItem('圆形布局', null, ()=>{\n                this.graph.layout.default = 'circle';\n                this.executeLayout();\n            }, submenuLayout);\n\n        }\n        \n    },\n    // 设置布局\n    executeLayout(){\n        let graph = this.graph.editor.graph;\n        let parent = graph.getDefaultParent();\n        let layout = this.graph.layout;\n        let model = graph.getModel();\n\n        // 布局定义\n        if(layout.default === 'hierarchical_vertical'){\n            // Layout hierarchical\n            model.beginUpdate();\n            try {\n                layout.inst = new mxHierarchicalLayout(graph, mxConstants.DIRECTION_NORTH);\n                layout.inst.edgeStyle = layout.edgeStyle;\n                layout.inst.intraCellSpacing = 80;\n                layout.inst.interRankCellSpacing = 80;\n                \n                layout.inst.execute(parent, null);\n\n            } finally {\n                let morph = new mxMorphing(graph);  \n                morph.addListener(mxEvent.DONE, function(){  \n                    model.endUpdate();  \n                });  \n                    \n                morph.startAnimation();  \n            }\n            \n        } else if(layout.default === 'hierarchical_horizontal'){\n            // Layout hierarchical\n            model.beginUpdate();\n            try {\n                layout.inst = new mxHierarchicalLayout(graph, mxConstants.DIRECTION_WEST);\n                layout.inst.edgeStyle = layout.edgeStyle;\n                layout.inst.intraCellSpacing = 80;\n                layout.inst.interRankCellSpacing = 80;\n                \n                layout.inst.execute(parent, null);\n            } finally {\n                let morph = new mxMorphing(graph);  \n                morph.addListener(mxEvent.DONE, function(){  \n                    model.endUpdate();  \n                });  \n                    \n                morph.startAnimation();  \n            }\n            \n        } else if(layout.default === 'organic'){\n            // Layout Organic\n            model.beginUpdate();\n            try {\n                layout.inst = new mxFastOrganicLayout(graph);\n                layout.inst.forceConstant = 140;\n                //layout.inst.execute(parent);\n\n                layout.inst.execute(parent,null);\n            } finally {\n                model.endUpdate();\n            }\n            \n        } else if(layout.default === 'tree_vertical'){\n            /* Layout tree vertical */\n            model.beginUpdate();\n            try {\n                let tmp = graph.getSelectionCell();\n                let roots = null;\n                let cells = [tmp];\n                \n                if ( tmp == null || model.getChildCount(tmp) == 0 ) {\n                    if (model.getEdgeCount(tmp) == 0){\n                        roots = graph.findTreeRoots(parent);\n                    }\n                } else {\n                    roots = graph.findTreeRoots(tmp);\n                }\n\n                if ( roots != null && roots.length > 0 ) {\n                    cells = roots;\n                }\n                \n                if( cells.length > 0 ) {\n                    _.forEach(cells,(v)=>{\n                        layout.inst = new mxCompactTreeLayout(graph, false);\n                        layout.inst.edgeRouting = false;\n                        layout.inst.levelDistance = 30;\n                        layout.inst.execute(parent, v);\n                    })\n                }\n\n            } finally {\n                let morph = new mxMorphing(graph);  \n                morph.addListener(mxEvent.DONE, function(){  \n                    model.endUpdate();  \n                });  \n                    \n                morph.startAnimation();  \n            }\n        } else if(layout.default === 'tree_horizontal'){\n            /* Layout tree horizontal */\n            model.beginUpdate();\n            try {\n                let tmp = graph.getSelectionCell();\n                let roots = null;\n                let cells = [tmp];\n                \n                if (tmp == null || model.getChildCount(tmp) == 0){\n                    if (model.getEdgeCount(tmp) == 0){\n                        roots = graph.findTreeRoots(parent);\n                    }\n                } else {\n                    roots = graph.findTreeRoots(tmp);\n                }\n\n                if (roots != null && roots.length > 0){\n                    cells = roots;\n                }\n                \n                if( cells.length > 0 ) {\n                    _.forEach(cells,(v)=>{\n                        layout.inst = new mxCompactTreeLayout(graph, true);\n                        layout.inst.edgeRouting = false;\n                        layout.inst.levelDistance = 30;\n                        layout.inst.execute(parent, v);\n                    })\n                }\n                \n            } finally {\n                let morph = new mxMorphing(graph);  \n                morph.addListener(mxEvent.DONE, function(){  \n                    model.endUpdate();  \n                });  \n                    \n                morph.startAnimation();  \n            }\n        } else {\n            /* Layout Circle */\n            model.beginUpdate();\n            try {\n                layout.inst = new mxCircleLayout(graph);\n                layout.inst.execute(parent, null);\n            } finally {\n                model.endUpdate();\n            }\n        }\n        \n    },\n    // 节点告警状态\n    onRefreshCellStatus(){\n        \n        let graph = this.graph.editor.graph;\n        let parent = graph.getDefaultParent();\n        \n        // 图所有节点\n        let cells = _.map(graph.getChildVertices(parent),v=>{\n                        return {gid: v.id, name: v.value};\n                    });\n\n        this.m3.callFS(\"/matrix/m3graph/graph_imap_data.js\", encodeURIComponent(JSON.stringify(cells))).then( rtn=>{\n            \n            graph.getModel().beginUpdate();\n\n            try {\n                \n                _.forEach(rtn.message,(v)=>{\n                    let id = v.gid;\n                    let status = v.status;\n                    let cell = graph.getModel().getCell(id);\n                    //let state = graph.view.getState(cell);\n                    \n                    if (cell != null) {\n                        \n                        // Resets\n                        graph.removeCellOverlays(cell);\n\n                        if (status >= 5) {\n                            graph.addCellOverlay(cell, this.createOverlayByTip(status, `${id}: 重大告警`));\n                        } else if (status >3 && status < 5) {\n                            graph.addCellOverlay(cell, this.createOverlayByTip(status, `${id}: 严重告警`));\n                        } else {\n                            graph.removeCellOverlays(cell);\n                        } \n                    \n                    }\n\n                })\n\n            } \n            finally {\n                graph.getModel().endUpdate();\n            }\n        } );\n    },\n    // 节点状态渲染图标\n    createOverlayByTip(image, tooltip) {                  \n        let overlay = new mxCellOverlay(new mxImage(`/static/assets/images/apps/png/severity/${image}.png`,24,24), tooltip, mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_TOP, new mxPoint(-10,15));\n        return overlay;\n    },\n    // 删除选择的节点\n    onDeleteSelectedCells(graph,includeEdges){\n        // Cancels interactive operations\n        graph.escape();\n        var cells = graph.getDeletableCells(graph.getSelectionCells());\n        \n        if (cells != null && cells.length > 0){\n            var parents = graph.model.getParents(cells);\n            graph.removeCells(cells, includeEdges);\n            \n            // Selects parents for easier editing of groups\n            if (parents != null){\n                var select = [];\n                \n                for (var i = 0; i < parents.length; i++){\n                    if (graph.model.contains(parents[i]) &&\n                        (graph.model.isVertex(parents[i]) ||\n                        graph.model.isEdge(parents[i]))){\n                        select.push(parents[i]);\n                    }\n                }\n                graph.setSelectionCells(select);\n            }\n        }\n    },\n    // 节点高亮定位显示\n    onCellPosition(row,hFlag,vFlag){\n        \n        let id = row.entity;\n        let editor = this.graph.editor; \n        let graph = editor.graph;\n        let cell = graph.getModel().getCell(id);\n\n        try{\n            // 根据cell数量决定视图是否缩放\n            if(this.graph.data.nodes.length > 10){\n                editor.execute(\"fit\");    \n            } else {\n                editor.execute(\"actualSize\");  \n            }\n            \n            let containerW = graph.container.clientWidth;\n            let containerH = graph.container.clientHeight;\n            let x =-cell.geometry.x + ( containerW - cell.geometry.width) / 2;\n            let y =-cell.geometry.y + ( containerH - cell.geometry.height) / 2;\n            \n            if( hFlag ){\n                x = x / 2;\n            }\n\n            if( vFlag ){\n                y = y / 2;\n            }\n            \n            graph.getView().setTranslate(x,y);\n            graph.scrollCellToVisible(cell);\n            graph.setSelectionCells([cell]);\n\n            _.delay(()=>{\n                let state = graph.view.getState(cell);\n                \n                if(this.graph.control.ifIcon){\n                    state.shape.node.getElementsByTagName(\"image\")[0].setAttribute('class', 'animated flash');\n                } else {\n                    state.shape.node.getElementsByTagName(\"ellipse\")[0].setAttribute('class', 'animated flash');\n                }\n            },500)\n\n            // 选择节点突出显示\n            graph.setCellStyles(mxConstants.STYLE_PERIMETER_SPACING, 8, [cell]);\n            \n        } catch(err){\n            \n            // 当前画布中不包含该实体\n            this.$message({\n                type: \"info\",\n                message: \"没有该实体 \"\n            })\n        }\n    },\n    // 画布清空\n    onCanvasClear(){\n        this.graph.editor.execute(\"selectAll\");\n        this.graph.editor.execute(\"delete\");\n    }\n  },\n};\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n    .el-container{\n        height: calc(100vh - 50px)!important;\n    }\n</style>\n\n<style>\n    .outlineContainer{\n        position:absolute;\n        overflow:hidden;\n        top:20px;\n        right:90px;\n        width:200px;\n        height:140px;\n        background:transparent;\n        box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);\n    }\n    /* mxgraph contextmenu style */\n    td.mxPopupMenuIcon div {\n        width:16px;\n        height:16px;\n    }\n    html div.mxPopupMenu {\n        -webkit-box-shadow:2px 2px 3px #d5d5d5;\n        -moz-box-shadow:2px 2px 3px #d5d5d5;\n        box-shadow:2px 2px 3px #d5d5d5;\n        _filter:progid:DXImageTransform.Microsoft.DropShadow(OffX=2, OffY=2, Color='#d0d0d0', Positive='true');\n        background:white;\n        position:absolute;\n        border:1px solid #e7e7e7;\n        padding:3px;\n    }\n    html table.mxPopupMenu {\n        border-collapse:collapse;\n        margin:0px;\n    }\n    html td.mxPopupMenuItem {\n        padding:7px 30px 7px 30px;\n        font-family: \"微软雅黑\";/* Microsoft YaHei,Helvetica Neue,Helvetica,Arial Unicode MS,Arial;*/\n        font-size:12px;\n    }\n    html td.mxPopupMenuIcon {\n        background-color:white;\n        padding:0px;\n    }\n    td.mxPopupMenuIcon .geIcon {\n        padding:2px;\n        padding-bottom:4px;\n        margin:2px;\n        border:1px solid transparent;\n        opacity:0.5;\n        _width:26px;\n        _height:26px;\n    }\n    td.mxPopupMenuIcon .geIcon:hover {\n        border:1px solid gray;\n        border-radius:2px;\n        opacity:1;\n    }\n    html tr.mxPopupMenuItemHover {\n        background-color: #f5f5f5;\n        color: black;\n    }\n    table.mxPopupMenu hr {\n        color:#cccccc;\n        background-color:#f5f5f5;\n        border:none;\n        height:1px;\n    }\n    table.mxPopupMenu tr {\n        font-size:4pt;\n    }\n</style>\n"]}]}